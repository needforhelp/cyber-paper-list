<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Illusion</title>
    <style>
        /* CSS 变量定义：深色模式下的颜色方案 */
        :root {
            --primary-color: #64b5f6; /* 主色调 */
            --primary-color-rgb: 100, 181, 246; /* 主色调的 RGB 值 */
            --secondary-color: #263238; /* 次要色调 */
            --accent-color: #5edcd0; /* 强调色 */
            --text-color: #e0e0e0; /* 主要文本颜色 */
            --light-text: #b0bec5; /* 浅色文本颜色 */
            --background-color: #121212; /* 背景颜色 */
            --card-background: #1e1e1e; /* 卡片背景颜色 */
            --border-color: #333; /* 边框颜色 */
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* 盒子阴影 */
            --delete-btn-bg: #e57373; /* 删除按钮背景色 */
            --delete-btn-hover-bg: #ef9a9a; /* 删除按钮悬停背景色 */
            --border-radius: 3px; /* 边框圆角 */

            --frosted-card-bg: rgba(30, 30, 30, 0.7); /* 磨砂效果卡片背景 */
            --frosted-main-bg: rgba(18, 18, 18, 0.7); /* 磨砂效果主背景 */
            --frosted-border: rgba(51, 51, 51, 0.7); /* 磨砂效果边框 */

            --blockquote-color: #b5b55b; /* 引用块文本颜色 */
            --blockquote-border-color: #cccc4d; /* 引用块边框颜色 */
            --blockquote-background-color: rgba(50, 50, 50, 0.3); /* 引用块背景颜色 */
            --color-swatch-border-color: rgba(255, 255, 255, 0.5); /* 颜色样本方块边框颜色 */
        }

        /* 浅色模式下的颜色方案 */
        body.light-mode {
            --primary-color: #228cdd;
            --primary-color-rgb: 34, 140, 221;
            --secondary-color: #d1d1d1;
            --accent-color: #92d3c3;
            --text-color: #212121;
            --light-text: #616161;
            --background-color: #e0e0e0;
            --card-background: #ffffff;
            --border-color: #bdbdbd;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --delete-btn-bg: #d76060;
            --delete-btn-hover-bg: #b04f4f;

            --frosted-card-bg: rgba(255, 255, 255, 0.7);
            --frosted-main-bg: rgba(224, 224, 224, 0.7);
            --frosted-border: rgba(189, 189, 189, 0.7);

            --blockquote-color: rgba(76, 134, 154, 1);
            --blockquote-border-color: #75b0b8;
            --blockquote-background-color: rgba(227, 227, 227, 0.2);
            --color-swatch-border-color: var(--border-color); /* 颜色样本方块边框颜色 */
        }

        /* 全局样式重置和字体设置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box; /* 盒模型为边框盒 */
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; /* 字体设置 */
        }

        /* 页面主体样式 */
        body {
            background-color: var(--background-color); /* 背景颜色 */
            color: var(--text-color); /* 文本颜色 */
            line-height: 1.6; /* 行高 */
            background-size: cover; /* 背景图片覆盖整个元素 */
            background-position: center; /* 背景图片居中 */
            background-repeat: no-repeat; /* 背景图片不重复 */
            background-attachment: fixed; /* 背景图片固定 */
            transition: background-color 0.3s ease; /* 背景颜色过渡效果 */
            min-height: 150vh; /* 最小高度，保证内容少时也能撑开 */
        }

        /* 容器样式，限制内容最大宽度并居中 */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 10px; /* 此内边距将应用于 header */
        }

        /* 头部样式 */
        header {
            display: flex; /* Flex 布局 */
            justify-content: space-between; /* 子元素两端对齐 */
            align-items: center; /* 子元素垂直居中 */
            margin: 15px 0;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color); /* 底部边框 */
            flex-wrap: wrap; /* 允许换行 */
            gap: 10px; /* 子元素间距 */
        }

        /* 标题样式 */
        h1 {
            color: var(--primary-color);
            font-size: 24px;
        }

        /* 主内容区域布局 */
        main {
            display: flex; /* Flex 布局 */
            flex-direction: row; /* 水平排列 */
            gap: 20px; /* 元素间距 */
            margin: -15px 0; 

            align-items: flex-start; /* 顶部对齐，防止侧栏高导致内容下移 */
            flex-wrap: nowrap; /* 不换行（如果屏幕太窄，媒体查询会处理） */
        }

        /* 侧边栏样式 */
        .sidebar {
            background-color: var(--frosted-card-bg); /* 磨砂背景 */
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 15px;
            height: fit-content; /* 高度自适应内容 */
            border: 1px solid var(--frosted-border);
            text-align: center;
            backdrop-filter: blur(10px); /* 背景模糊效果 */
            -webkit-backdrop-filter: blur(10px); /* 兼容 Safari */
            flex-shrink: 0; /* 防止侧边栏被压缩 */
            flex: 0 0 150px; /* 固定宽度：150px*/
            width: auto; 
            max-width: 33%; /* 可选，防止侧栏在大屏过宽 */
        }

        /* 侧边栏标题样式 */
        .sidebar h3 {
            margin-bottom: 15px;
            color: var(--primary-color);
            font-size: 18px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            user-select: none; /* 禁止用户选择文本 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* 分类列表样式 */
        .categories {
            list-style: none; /* 移除列表点 */
            margin-bottom: 20px;
            padding-left: 0;
        }

        /* 分类列表项样式 */
        .categories li {
            margin-bottom: 8px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        /* 为“全部作品”分类添加加粗效果 */
        .categories li a[data-category="全部作品"] {
            font-weight: bold;
        }

        /* 分类链接样式 */
        .categories li a {
            display: inline-block;
            text-align: center;
            text-decoration: none; /* 移除下划线 */
            color: var(--text-color);
            padding: 8px 10px;
            border-radius: var(--border-radius);
            transition: all 0.3s;
            font-size: 14px;
            width: 100%;
            flex-grow: 1;
        }

        /* 分类链接悬停和激活状态 */
        .categories li a:hover,
        .categories li a.active {
            background-color: var(--secondary-color);
            color: var(--primary-color);
        }

        /* 分类排序模式下的可拖拽样式 */
        .categories.sorting-active li.draggable {
            cursor: grab; /* 抓取光标 */
        }

        .categories.sorting-active li.draggable:active {
            cursor: grabbing; /* 抓取中光标 */
        }

        .categories.sorting-active li.dragging {
            opacity: 0.5; /* 拖拽时半透明 */
            border: 1px dashed var(--primary-color); /* 虚线边框 */
        }

        /* 拖拽到上方时的样式 */
        .categories.sorting-active li.drag-over {
            border-top: 2px solid var(--accent-color);
        }

        /* 拖拽到下方时的样式 */
        .categories.sorting-active li.drag-over.drag-over-bottom {
            border-top: none;
            border-bottom: 2px solid var(--accent-color);
        }

        /* 排序模式下禁用链接点击 */
        .categories.sorting-active li a {
            pointer-events: none;
        }

        /* 排序模式下隐藏删除按钮 */
        .categories.sorting-active li .category-delete-btn {
            display: none !important;
        }

        /* 侧边栏新建按钮样式 */
        .sidebar-new-btn {
            display: block;
            background-color: var(--accent-color);
            color: #121212;
            text-align: center;
            padding: 10px;
            border-radius: var(--border-radius);
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            text-decoration: none;
            margin-top: 15px;
            font-size: 14px;
            width: 100%;
        }

        /* 内容区域样式 */
        .content-area {
            background-color: var(--frosted-card-bg);
            border: 1px solid var(--frosted-border);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 20px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);

            flex-grow: 1; /* 使内容区域宽度自适应 */
            min-width: 0; /* 允许 flex 子项正确收缩，避免 overflow 导致换行 */
        }

        /* 内容头部样式 */
        .content-header {
            display: none;/* 隐藏顶栏,但保留原顶栏代码以防万一 */
            /* flex-direction: column; */
            /* align-items: center; */
            /* margin-bottom: 20px; */
            /* padding-bottom: 15px; */
            /* flex-wrap: wrap; */
            /* gap: 10px; */
        }

        /* 内容头部有底部边框时的样式 */
        .content-header.has-bottom-border {
            border-bottom: 1px solid var(--border-color);
        }

        /* 列表模式控制区域样式 */
        #listModeControls {
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* 详情模式控制区域样式 */
        #detailModeControls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        /* 批量操作按钮组样式 */
        .batch-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* 侧边栏中实际批量操作区域样式 */
        .sidebar #actualBatchActions {
            flex-direction: column;
            align-items: stretch;
            width: 100%;
            margin-top: 10px;
        }

        /* 侧边栏中批量操作按钮和选择框样式 */
        .sidebar #actualBatchActions .btn,
        .sidebar #actualBatchActions select {
            width: 100%;
            min-width: 120px; /* 保证下拉框足够宽 */
            font-size: 13px;  /* 字体稍大更易读 */
            text-align-last: center; /* 兼容部分浏览器 */
        }

        /* 侧边栏中全选复选框容器样式 */
        .sidebar #actualBatchActions #selectAllCheckboxContainer {
            justify-content: flex-start;
            width: 100%;
            margin-bottom: 5px;
        }

        /* 卡片容器样式 (网格布局) */
        .card-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(265px, 1fr)); /* 自动填充，最小宽度265px */
            gap: 15px;/* 卡片间距 */
            justify-content: stretch;/* 让网格项填满整个容器宽度 */
            transition: all 0.3s ease;
            max-width: 100%; /* 限制卡片容器的最大宽度 */
            margin: 0; /* 使卡片容器水平居中 */
            padding: 2px; /* 容器内部左右留白 */
            box-sizing: border-box; /* 确保 padding 不会影响整体布局溢出 */
        }

        /* 卡片容器在列表模式下的样式 (Flex 布局) */
        .card-container.list-mode {
            display: flex;
            flex-direction: column;
            max-width: 100%;
            margin: 0;
            gap: 10px;
            padding: 0 6px;
            box-sizing: border-box;
        }

        /* 单个卡片样式 */
        .card {
            background-color: var(--frosted-card-bg);
            border: 1px solid var(--frosted-border);
            border-radius: var(--border-radius);
            overflow: hidden;
            transition: all 0.2s;
            padding: 10px;
            position: relative;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding-left: 30px; 
            box-sizing: border-box;
            display: flex; /* 将卡片设置为 Flex 容器 */
            flex-direction: column; /* 子元素垂直堆叠 */
        }

        /* 鼠标悬停在卡片上时显示置顶按钮 */
        .card:hover .pin-btn { 
            display: flex;    
        }                 

        /* 置顶按钮样式 */
        .pin-btn {
            position: absolute;
            top: 3px; /* 距离顶部 */
            right: 3px; /* 距离右侧 */
            background-color: transparent; /* 背景色 */
            color: #fff; /* 白色图标 */
            opacity: 0.5;
            border: none;
            border-radius: 6px; /* 按钮圆角 */
            width: 17px;
            height: 19px;
            display: none;/* 默认不显示 */
            justify-content: center;
            align-items: center;
            font-size: 10px;
            cursor: pointer; /* 鼠标悬停时显示为手型光标 */
            transition: background-color 0.3s, transform 0.2s;
            z-index: 10; /* 确保在卡片内容之上 */
            padding: 0; /* 移除默认内边距 */
        }

        .pin-btn:hover {
            background-color: transparent; /* 悬停时背景色 */
            transform: scale(1.1); /* 悬停时按钮放大 10%  */
        }

        /* 置顶卡片样式 */
        .card.pinned {
            border: 2px solid var(--primary-color); /* 置顶卡片添加主色边框，非透明模式可见 */
        }

        /* 置顶按钮激活状态（表示已置顶） */
        .pin-btn.pinned-active {
            display: flex !important; /* 添加 !important 提高优先级 */
            background-color: transparent; /* 背景色 */
            color: var(--primary-color); /* 文本颜色 */
        }

        /* 浅色模式下置顶按钮样式 */
        body.light-mode .pin-btn {
            background-color: transparent;
            color: var(--text-color);
        }

        body.light-mode .pin-btn:hover {
            background-color: rgba(0, 0, 0, 0.1); 
        }

        body.light-mode .pin-btn.pinned-active {
            background-color: transparent; 
            color: var(--primary-color); 
        }

        /* 列表模式下卡片样式 */
        .card-container.list-mode .card {
            width: 100%;
            padding: 10px 15px;
            margin-bottom: 0;
            padding-left: 30px;
        }

        /* 卡片悬停效果 */
        .card:hover {
            transform: translateY(-5px); /* 向上移动 */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* 阴影变大 */
        }

        /* 卡片标题样式 */
        .card-title {
            font-size: 16px;
            margin-bottom: 10px;
            color: var(--primary-color);
            font-weight: 600;
            margin-top: 5px;
        }

        /* 卡片内容包装器样式 */
        .card-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            /* 让内容包装器弹性增长，将操作按钮推到底部 */
            flex-grow: 1; 
        }

        /* 卡片文本样式 */
        .card-text {
            font-size: 14px;
            color: var(--light-text);
            line-height: 1.5;
            width: calc(100% - 100px); /* 减去右侧元信息的宽度 */
        }

        /* 卡片右侧元信息样式 */
        .card-meta-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 12px;
            color: var(--light-text);
            min-width: 90px;
            text-align: right;
        }

        /* 卡片操作按钮组样式 */
        .card-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: auto; /* 将操作按钮组推到卡片底部 */
        }

        /* 操作按钮样式 */
        .action-btn {
            font-size: 10px;
            padding: 3px 6px;
            background-color: var(--secondary-color);
            color: var(--light-text);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s;
        }

        /* 通用按钮样式 */
        .btn {
            background-color: var(--accent-color);
            color: #121212;
            padding: 8px 16px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            /* Added for centering text within the button */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: normal; /* Allow text to wrap */
        }

        /* 按钮悬停效果 */
        .btn:hover,
        .action-btn:hover {
            background-color: #80cbc4;
        }

        /* 亮色取消按钮样式 */
        .btn.cancel-btn-bright {
            background-color: #90a4ae;
            color: #121212;
        }

        /* 亮色取消按钮悬停效果 */
        .btn.cancel-btn-bright:hover {
            background-color: #b0bec5;
        }

        /* 主色调蓝色按钮样式 */
        .btn-primary-blue {
            background-color: var(--primary-color); /* Use primary color for background */
            color: #121212; /* Dark text for light primary color */
        }

        .btn-primary-blue:hover {
            filter: brightness(1.1); /* Slightly brighter on hover */
        }

        /* 浅色模式下主色调蓝色按钮样式 */
        body.light-mode .btn-primary-blue {
        background-color: #64b5f6; /* 将背景色设置为黑夜模式的主色调 */
        color: #121212; /* 将文本颜色设置为黑夜模式的文本颜色 */
        }

        body.light-mode .btn-primary-blue:hover {
            filter: brightness(1.1);
        }

        /* 回收站分类样式 */
        .trash-category {
            background-color: var(--delete-btn-bg);
            color: #fff;
            font-weight: bold;
        }

        /* 回收站分类悬停效果 */
        .trash-category:hover {
            background-color: var(--delete-btn-hover-bg);
            color: #fff;
        }

        /* 浅色模式下回收站分类样式 */
        body.light-mode .trash-category {
            background-color: var(--delete-btn-bg);
            color: #fff;
        }

        body.light-mode .trash-category:hover {
            background-color: var(--delete-btn-hover-bg);
            color: #fff;
        }

        /* 回收站通知样式 */
        .trash-notification {
            background-color: rgba(255, 82, 82, 0.2);
            border: 1px solid #ff5252;
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* 回收站操作按钮组样式 */
        .trash-actions {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }

        /* 恢复按钮样式 */
        .restore-btn {
            background-color: #64b5f6;
            color: #121212;
        }

        /* 永久删除按钮样式 */
        .permanent-delete-btn {
            background-color: #e57373;
            color: #fff;
        }

        /* 通知消息框样式 */
        .notification {
            position: fixed; /* 固定定位 */
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: var(--border-radius);
            background-color: var(--frosted-card-bg);
            border: 1px solid var(--frosted-border);
            box-shadow: var(--box-shadow);
            z-index: 1000; /* 层级最高 */
            transform: translateX(150%); /* 初始状态在屏幕外 */
            transition: transform 0.3s ease; /* 过渡效果 */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* 通知显示状态 */
        .notification.show {
            transform: translateX(0); /* 移动到屏幕内 */
        }

        /* 成功通知样式 */
        .notification.success {
            border-left: 4px solid #4db6ac;
        }

        /* 错误通知样式 */
        .notification.error {
            border-left: 4px solid #e57373;
        }

        /* 文章详情容器样式 */
        .article-detail-container {
            grid-column: 1 / -1; /* 占据所有列 */
            background-color: var(--frosted-card-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            border: 1px solid var(--frosted-border);
            word-wrap: break-word; /* 单词换行 */
            overflow-wrap: break-word; /* 强制换行 */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            /* 新增：Flexbox 布局，使其子元素可以填充剩余高度 */
            display: flex;
            flex-direction: column;
            min-height: 60vh; /* 确保容器有足够的最小高度 */
        }

        /* 文章头部容器样式 */
        .article-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        /* 文章头部标题样式 */
        .article-header-container h2 {
            color: var(--primary-color);
            margin: 0;
            font-size: 20px;
        }

        /* 文章元信息容器样式 */
        .article-meta-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            color: var(--light-text);
            font-size: 14px;
            text-align: right;
        }

        /* 文章描述容器样式 */
        .article-description-container {
            font-size: 14px;
            color: var(--light-text);
            font-style: italic;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed var(--border-color); /* 虚线底部边框 */
        }

        /* 文章内容容器样式 */
        .article-content-container {
            line-height: 1.8;
            margin: 15px 0;
            white-space: pre-wrap; /* 保留空白符和换行符 */
            padding: 10px;
        }

        /* 分页器样式 */
        .pagination {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }

        /* 分页按钮样式 */
        .pagination-btn {
            background-color: var(--secondary-color);
            color: var(--light-text);
            border: 1px solid var(--border-color);
            padding: 8px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s;
        }

        /* 分页按钮悬停和激活状态 */
        .pagination-btn:hover:not(:disabled),
        .pagination-btn.active {
            background-color: var(--primary-color);
            color: #121212;
        }

        /* 分页按钮禁用状态 */
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* 模态框遮罩层样式 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* 半透明黑色背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0; /* 初始透明 */
            visibility: hidden; /* 初始隐藏 */
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        /* 模态框遮罩层显示状态 */
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* 模态框内容样式 */
        .modal-content {
            background-color: var(--frosted-card-bg);
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            max-width: 500px;
            width: 90%;
            text-align: center;
            transform: translateY(-20px); /* 初始向上偏移 */
            transition: transform 0.3s ease;
            border: 1px solid var(--frosted-border);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* 模态框内容显示状态 */
        .modal-overlay.show .modal-content {
            transform: translateY(0); /* 恢复到原位 */
        }

        /* 模态框标题样式 */
        .modal-content h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 22px;
        }

        /* 模态框输入框样式 */
        .modal-content input {
            width: calc(100% - 20px); /* 宽度减去内边距 */
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid var(--frosted-border);
            background-color: var(--frosted-main-bg);
            color: var(--text-color);
            border-radius: var(--border-radius);
            font-size: 16px;
            outline: none;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        /* 模态框消息段落样式 */
        #modalMessageP {
            white-space: pre-wrap; /* 保留空白符和换行符，实现分点分段 */
            line-height: 1.8;      /* 调整行距，例如设置为1.8倍字高 */
            text-align: left;      /* 将文本左对齐，使分点列表更整洁 */
            margin-bottom: 15px;   /* 增加与下方元素的间距 */
        }

        /* 模态框按钮组样式 */
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        /* 分类删除按钮样式 */
        .category-delete-btn {
            background-color: transparent;
            color: #FFB6C1;
            border: none;
            border-radius: 50%; /* 圆形 */
            width: 17px;
            height: 17px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            position: absolute; /* 绝对定位 */
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            display: none; /* 默认隐藏 */
            align-items: center; /* 垂直居中 */
            justify-content: center; /* 水平居中 */
            line-height: 1;/* 设置行高 */
            padding: 0;/* 移除内边距 */
            transition: background-color 0.2s; /* 过渡效果 */
            z-index: 10;/* 确保层级 */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3); /* 添加阴影效果 */
        }

        /* 分类删除按钮悬停效果 */
        .category-delete-btn:hover {
            background-color: transparent;
        }

        /* 浅色模式下按钮样式 */
        body.light-mode .btn,
        body.light-mode .sidebar-new-btn {
            color: #121212;
        }

        body.light-mode .color-palette {
            background-color: rgba(255, 255, 255, 0.5); /* 浅色模式下为半透明 */
        }

        /* 浅色模式下按钮悬停效果 */
        body.light-mode .btn:hover {
            background-color: var(--accent-color);
            filter: brightness(1.1); /* 增加亮度 */
        }

        /* 浅色模式下亮色取消按钮样式 */
        body.light-mode .btn.cancel-btn-bright {
            background-color: #90a4ae;
            color: #ffffff;
        }

        /* 浅色模式下亮色取消按钮悬停效果 */
        body.light-mode .btn.cancel-btn-bright:hover {
            background-color: #757575;
        }

        /* 浅色模式下分页按钮悬停和激活状态 */
        body.light-mode .pagination-btn:hover:not(:disabled),
        body.light-mode .pagination-btn.active {
            background-color: var(--primary-color);
            color: #ffffff;
        }

        /* 浅色模式下操作按钮悬停效果 */
        body.light-mode .action-btn:hover {
            background-color: #b0bec5;
        }

        /* 浅色模式下恢复按钮样式 */
        body.light-mode .restore-btn {
            background-color: #2196f3;
            color: #ffffff;
        }

        /* 浅色模式下永久删除按钮样式 */
        body.light-mode .permanent-delete-btn {
            background-color: var(--delete-btn-bg); /* Use the same red in light mode */
            color: #ffffff;
        }

        /* 浅色模式下输入框和选择框样式 */
        body.light-mode .search-bar-in-menu input,
        body.light-mode #recategorizeSelect,
        body.light-mode .modal-content input,
        body.light-mode .article-detail-container input,
        body.light-mode .article-detail-container select,
        body.light-mode .article-detail-container textarea {
            background-color: var(--frosted-main-bg);
            color: var(--text-color);
            border-color: var(--frosted-border);
        }

        /* 浅色模式下文章详情容器样式 */
        body.light-mode .article-detail-container {
            background-color: var(--frosted-card-bg);
            color: var(--text-color);
        }

        /* 浅色模式下文章内容容器文本颜色 */
        body.light-mode .article-detail-container .article-content-container {
            color: var(--text-color);
        }

        /* 浅色模式下文章描述和元信息文本颜色 */
        body.light-mode .article-detail-container .article-description-container,
        body.light-mode .article-detail-container .article-meta-container {
            color: var(--light-text);
        }

        /* 主题切换按钮样式 */
        #themeToggle {
            background-color: transparent;/* 按钮背景透明 */
            border: 1px solid var(--border-color);/* 使用主题变量设置边框颜色 */
            color: var(--text-color);/* 按钮文字颜色采用主题变量 */
            padding: 7px 7px;/* 按钮上下内边距7px，左右7px */
            border-radius: var(--border-radius);/* 使用主题变量设置圆角 */
            cursor: pointer;/* 鼠标悬停时显示为可点击手型 */
            font-size: 14px;/* 按钮文字大小 */
            font-weight: 600;/* 按钮文字加粗 */
            transition: all 0.2s;/* 所有属性变化时平滑过渡 */
        }

        /* 主题切换按钮悬停效果 */
        #themeToggle:hover {
            background-color: var(--secondary-color);
        }

        /* 浅色模式下主题切换按钮样式 */
        body.light-mode #themeToggle {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        body.light-mode #themeToggle:hover {
            background-color: var(--secondary-color);
        }

        /* 图标按钮通用样式 */
        .icon-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            display: grid;
            place-items: center; /* 居中内容 */
            font-size: 18px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        /* 设置菜单切换按钮样式 */
        #settingsMenuToggle {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        #settingsMenuToggle:hover {
            background-color: var(--secondary-color);
        }

        /* 浅色模式下设置菜单切换按钮样式 */
        body.light-mode #settingsMenuToggle {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        body.light-mode #settingsMenuToggle:hover {
            background-color: var(--secondary-color);
        }

        /* 视图模式切换按钮样式 */
        #toggleViewModeBtn {
            background-color: var(--accent-color);
            color: #121212;
            height: 32px;
            width: 29px; 
            min-width: 28px;
            padding-left: 0;
            padding-right: 0;
        }

        #toggleViewModeBtn:hover {
            background-color: #80cbc4;
        }

        /* 浅色模式下视图模式切换按钮样式 */
        body.light-mode #toggleViewModeBtn {
            background-color: var(--accent-color);
            color: #ffffff;
        }

        body.light-mode #toggleViewModeBtn:hover {
            filter: brightness(1.1);
        }

        /* 退出排序模式按钮样式 */
        #exitSortingModeBtn {
            display: none; /* 默认隐藏 */
            margin-top: 10px;
            background-color: var(--primary-color);
            color: #121212;
        }

        /* 文献输入组样式 */
        .literature-input-group,
        .date-input-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 15px;
        }

        /* 文献输入组和日期输入组的子元素样式 */
        .literature-input-group>div,
        .date-input-group>div {
            flex: 0 0 calc(50% - 7.5px); /* 每行两个，留出间距 */
            display: flex;
            flex-direction: column;
        }

        /* 文献输入组和日期输入组的输入框样式 */
        .literature-input-group input,
        .date-input-group input {
            width: 100%;
            padding: 10px;
            background-color: var(--frosted-card-bg);
            color: var(--text-color);
            border: 1px solid var(--frosted-border);
            border-radius: var(--border-radius);
            outline: none;
            font-size: 16px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        /* 加密日期行样式 */
        .encryption-date-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        /* 加密日期行子元素样式 */
        .encryption-date-row>div {
            flex: 1; /* 弹性占据空间 */
            min-width: 280px;
        }

        /* 加密选项样式 */
        .encryption-options {
            margin-bottom: 0 !important;
        }

        /* 编辑器工具栏样式 */
        .editor-toolbar {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--secondary-color);
            flex-wrap: wrap;
            position: relative;
        }

        /* 编辑器工具栏按钮样式 */
        .editor-toolbar button {
            background-color: var(--primary-color);
            color: #121212;
            border: none;
            padding: 4px 8px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.3s, opacity 0.3s, border 0.3s;
            opacity: 0.5;
        }

        /* 编辑器工具栏按钮悬停效果 */
        .editor-toolbar button:hover {
        background-color: #80cbc4;
        opacity: 0.8; 
        }

        /* 浅色模式下编辑器工具栏按钮样式 */
        body.light-mode .editor-toolbar button {
            color: #ffffff;
            opacity: 0.3;
        }

        /* 浅色模式下编辑器工具栏按钮悬停样式 */
        body.light-mode .editor-toolbar button:hover {
            background-color: var(--primary-color);
            filter: brightness(1.1);
        }

        /* 编辑器工具栏激活按钮样式 */
        .editor-toolbar button.active {
            background-color: var(--secondary-color);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            opacity: 1;
        }

        /* 浅色模式下编辑器工具栏激活按钮样式 */
        body.light-mode .editor-toolbar button.active {
            background-color: var(--primary-color);
            color: #ffffff;
            border: 1px solid var(--secondary-color);
            opacity: 1;
        }

        /* 引用块样式 */
        blockquote {
            font-style: normal;
            color: var(--blockquote-color);
            margin: 10px 0;
            padding: 0;
            border-left: 1.5px solid var(--blockquote-border-color);
            background-color: var(--blockquote-background-color);
            padding: 4px 20px;
            border-radius: 1px;
            font-size: 14px;
            font-family: "楷体", "Microsoft YaHei", sans-serif; /* 楷体字体 */
        }

            /* Ensure font-family is maintained for formatted text within blockquote */
            blockquote b,
            blockquote i,
            blockquote u,
            blockquote s,
            blockquote strong,
            blockquote em,
            blockquote strike,
            blockquote font,
            blockquote span {
                font-family: "楷体", "Microsoft YaHei", sans-serif !important;
            }
        /* 内容编辑器区域样式 */
        .content-editor-div {
            height: 400px;
            overflow-y: auto;
            padding: 10px;
            margin: 15px 0;
            background-color: var(--frosted-card-bg);
            color: var(--text-color);
            border: 1px solid var(--frosted-border);
            border-radius: var(--border-radius);
            resize: vertical; /* 允许垂直方向调整大小 */
            outline: none;
            position: relative;
            line-height: 1.8;
            white-space: pre-wrap;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        /* 内容编辑器自动增大高度样式 */
        .content-editor-div.auto-grow {
            height: auto; /* 高度根据内容自动调整 */
            min-height: 200px; /* 最小高度 */
            max-height: none; /* 移除最大高度限制 */
            overflow-y: hidden; /* 隐藏垂直滚动条 */
            resize: none; /* 禁用手动调整大小 */
        }

        /* 内容编辑器为空时的占位符样式 */
        .content-editor-div:empty:before {
            content: attr(data-placeholder); /* 显示 data-placeholder 属性的值 */
            color: var(--light-text);
            pointer-events: none; /* 不响应鼠标事件 */
            position: absolute;
            top: 10px;
            left: 10px;
        }

        /* 内容编辑器中的粗体样式 */
        .content-editor-div b,
        .content-editor-div strong {
            font-weight: bold;
            font-family: inherit !important; /* 确保字体继承 */
        }

        /* 内容编辑器中的斜体样式 */
        .content-editor-div i,
        .content-editor-div em {
            font-style: italic;
            font-family: inherit !important; /* 确保字体继承 */
        }

        /* 内容编辑器中的下划线样式 */
        .content-editor-div u {
            text-decoration: underline;
            font-family: inherit !important; /* 确保字体继承 */
        }

        /* 内容编辑器中的删除线样式 */
        .content-editor-div s,
        .content-editor-div strike {
            text-decoration: line-through;
            font-family: inherit !important; /* 确保字体继承 */
        }

        /* 新增：确保所有 span 标签（包括用于格式化的 span）继承字体 */
        .content-editor-div span {
            font-family: inherit;
        }

        /* 内容编辑器滚动条样式（Webkit 浏览器） */
        .content-editor-div::-webkit-scrollbar {
            width: 8px;
        }

        .content-editor-div::-webkit-scrollbar-track {
            background: transparent;
        }

        .content-editor-div::-webkit-scrollbar-thumb {
            background-color: var(--light-text);
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }

        .content-editor-div::-webkit-scrollbar-thumb:hover {
            background-color: var(--primary-color);
        }

        /* 设置菜单容器样式 */
        .settings-menu-container {
            position: relative;
            display: inline-block;
            margin-left: auto;
        }

        /* 设置下拉菜单内容样式 */
        .settings-dropdown-content {
            display: none; /* 默认隐藏 */
            position: absolute;
            background-color: var(--frosted-card-bg);
            min-width: 350px;
            box-shadow: var(--box-shadow);
            z-index: 100;
            right: 0;
            border-radius: var(--border-radius);
            padding: 15px;
            border: 1px solid var(--frosted-border);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            flex-direction: column;
            gap: 15px;
            top: 100%; /* 定位在父元素下方 */
            margin-top: 10px;
        }

        /* 设置下拉菜单显示状态 */
        .settings-dropdown-content.show {
            display: flex;
        }

        /* 菜单内搜索栏样式 */
        .search-bar-in-menu {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        /* 菜单内搜索输入框样式 */
        .search-bar-in-menu input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            background-color: var(--frosted-card-bg);
            color: var(--text-color);
            border-radius: var(--border-radius);
            outline: none;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* 菜单内搜索按钮样式 */
        .search-bar-in-menu button {
            background-color: #89c3c8;
            color: #121212;
            border: none;
            padding: 0 8px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
            font-size: 16px;
        }

        /* 组合设置按钮组样式 */
        .combined-settings-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
            justify-content: space-between;
        }

        /* 组合设置按钮和标签按钮样式 */
        .combined-settings-buttons .btn,
        .combined-settings-buttons label.btn {
            flex: 1 1 auto; /* 弹性伸缩 */
            min-width: 70px;
            padding: 8px 10px;
            font-size: 13px;
            white-space: nowrap; /* 不换行 */
        }

        /* 提示按钮样式 */
        .combined-settings-buttons #tipBtn {
            min-width: 30px;
            flex: 0 0 auto;
        }

        /* 浅色模式下组合设置按钮和标签按钮样式 */
        body.light-mode .combined-settings-buttons label.btn,
        body.light-mode .combined-settings-buttons .btn {
            color: #ffffff;
        }

        /* 透明模式下侧边栏和内容区域样式 */
        body.transparent-mode .sidebar,
        body.transparent-mode .content-area {
            background-color: transparent !important; /* 背景透明 */
            border-color: transparent !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        /* 透明模式下卡片样式 */
        body.transparent-mode .card {
            background-color: rgba(30, 30, 30, 0.5) !important; /* 半透明背景 */
            border-color: transparent !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        /* 浅色透明模式下卡片样式 */
        body.light-mode.transparent-mode .card {
            background-color: rgba(255, 255, 255, 0.5) !important;
        }

        /* 透明模式下特定元素禁用模糊效果 */
        body.transparent-mode .notification,
        body.transparent-mode .article-detail-container,
        body.transparent-mode .modal-content,
        body.transparent-mode .search-bar-in-menu input,
        body.transparent-mode .modal-content input,
        body.transparent-mode .literature-input-group input,
        body.transparent-mode .date-input-group input,
        body.transparent-mode .content-editor-div,
        body.transparent-mode .trash-notification {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        /* 表单头部行样式 */
        .form-header-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }

        /* 表单头部行子元素样式 */
        .form-header-row>div {
            flex: 1;
            min-width: 150px;
            display: flex;
            flex-direction: column;
        }

        /* 表单头部行分类组样式 */
        .form-header-row .category-group {
            flex: 0 0 200px;
            max-width: 250px;
        }

        /* 加密工具栏行样式 */
        .encryption-toolbar-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: flex-start;
        }

        /* 加密工具栏行中的加密选项样式 */
        .encryption-toolbar-row .encryption-options {
            flex: 0 0 300px;
            max-width: 40%;
            margin-bottom: 0 !important;
        }

        /* 加密工具栏行中的编辑器工具栏包装器样式 */
        .encryption-toolbar-row .editor-toolbar-wrapper {
            flex: 1;
            min-width: 250px;
            display: flex; /* 将其设置为 Flex 容器 */
            justify-content: flex-end; /* 将其内部内容（工具栏）推向右侧 */
        }

        /* 新增：颜色选择器按钮及其面板的包装器 */
        .color-picker-wrapper, .font-picker-wrapper, .alignment-picker-wrapper { /* Added alignment-picker-wrapper */
            position: relative; /* 使其成为颜色选择面板的定位上下文 */
        }

        /* 颜色选择器面板样式 */
        .color-palette, .font-palette, .alignment-palette { 
            position: absolute;
            background-color: rgba(30, 30, 30, 0.5); /* 深色模式下为半透明 */
            border: 2px solid var(--frosted-border);
            border-radius: var(--border-radius);
            padding: 8px;
            display: flex;
            gap: 5px;
            z-index: 10;
            box-shadow: var(--box-shadow);
            margin-top: 5px;
            top: 100%;
            left: 50%; /* 将左边缘移动到父容器的中心 */
            transform: translateX(-50%); /* 向左平移自身宽度的一半，实现居中 */
        }

        /* 颜色样本方块样式 */
        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 2px solid var(--color-swatch-border-color); /* 修改为新的 CSS 变量 */
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: var(--text-color);
            background-color: var(--secondary-color); /* Default background for swatches */
        }

        /* 浅色模式下颜色样本方块的边框 */
        body.light-mode .color-swatch {
            border: 2px solid rgba(0, 0, 0, 0.5); /* 新增的边框颜色（白天模式） */
        }

        /* 字体样本方块样式 */
        .font-swatch {
            min-width: 32px; /* 按钮宽度 */
            padding: 3px 8px; /* 内边距 */
            border-radius: 4px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: var(--text-color);
            background-color: var(--secondary-color); /* Default background for swatches */
        }

        /* 对齐方式样本方块样式 */
        .alignment-swatch {
            width: 28px; 
            height: 28px;
            padding: 0;
            display: grid;
            place-items: center;
            font-size: 18px; /* For unicode icons or text */
            border: 1px solid var(--border-color); /* Add border for visibility */
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            background-color: var(--secondary-color);
            color: var(--text-color);
        }

        /* 颜色样本方块悬停效果 */
        .color-swatch:hover, .font-swatch:hover, .alignment-swatch:hover { /* Added alignment-swatch */
            transform: scale(1.1);
            box-shadow: 0 0 5px rgba(var(--primary-color-rgb), 0.5);
        }

        /* 清除颜色样本方块样式 */
        .clear-color-swatch {
            background-color: transparent !important; /* 透明背景色 */
            color: var(--text-color) !important;
        }

        /* 字体样本方块的特定字体 */
        .font-swatch[data-font="黑体"] { font-family: "黑体", "SimHei", sans-serif; }
        .font-swatch[data-font="宋体"] { font-family: "宋体", "SimSun", serif; }
        .font-swatch[data-font="楷体"] { font-family: "楷体", "KaiTi", cursive; }
        .font-swatch[data-font="仿宋"] { font-family: "仿宋", "FangSong", monospace; }


        /* 媒体查询：屏幕宽度小于等于 768px 时的响应式布局 */
        @media (max-width: 768px) {
            main {
                grid-template-columns: 1fr; /* 单列布局 */
                width: 100%; /* 在小屏幕上，使用父元素（body）的 100% 宽度 */
                left: auto; /* 重置 left 定位 */
                transform: none; /* 重置 transform */
                padding: 0 20px; /* 确保移动端仍有内边距作为页面边距 */
            }

            .batch-actions {
                flex-direction: column; /* 垂直排列 */
                align-items: flex-start;
                gap: 10px;
            }

            .action-buttons {
                width: 100%;
                justify-content: flex-start;
            }

            .article-header-container {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .article-meta-container {
                flex-direction: column;
                gap: 5px;
            }

            .form-header-row {
                flex-direction: column;
                gap: 0 !important;
            }

            .form-header-row>div {
                flex: none !important;
                width: 100%;
            }

            .form-header-row>div:first-child {
                margin-bottom: 15px;
            }

            .literature-input-group>div,
            .date-input-group>div {
                flex: 0 0 100%; /* 单列占据全部宽度 */
            }

            .encryption-toolbar-row {
                flex-direction: column;
                gap: 0 !important;
            }

            .encryption-toolbar-row>div {
                flex: none;
                width: 100%;
            }

            .encryption-toolbar-row .encryption-options {
                margin-bottom: 15px !important;
            }

            header {
                flex-direction: column;
                align-items: flex-start;
            }

            .settings-menu-container {
                width: 100%;
                margin-left: 0;
                margin-top: 10px;
            }

            .settings-dropdown-content {
                position: relative; /* 相对定位 */
                width: 100%;
                min-width: unset;
                right: auto;
                left: 0;
                box-shadow: none;
                border: none;
                padding: 0;
                background-color: transparent;
                backdrop-filter: none;
                -webkit-backdrop-filter: none;
                margin-top: 0;
            }

            .settings-dropdown-content.show {
                display: flex;
            }

            .settings-dropdown-content .combined-settings-buttons,
            .settings-dropdown-content .search-bar-in-menu {
                flex-direction: column;
                gap: 10px;
            }

            .settings-dropdown-content .combined-settings-buttons .btn,
            .settings-dropdown-content .combined-settings-buttons label.btn,
            .search-bar-in-menu input,
            .search-bar-in-menu button {
                width: 100%;
                flex-grow: 0;
            }
        }

        /* 媒体查询：屏幕宽度小于等于 768px 时批量操作的响应式布局 */
        @media (max-width: 768px) {
            #actualBatchActions.batch-actions {
                flex-direction: column;
                align-items: center;
            }

            #actualBatchActions.batch-actions>div,
            #actualBatchActions.batch-actions button,
            #actualBatchActions.batch-actions select {
                width: 100%;
            }
        }

        /* 媒体查询：屏幕宽度小于等于 480px 时的响应式布局 */
        @media (max-width: 480px) {
            .modal-content {
                padding: 20px;
            }

            .modal-content h2 {
                font-size: 20px;
            }

            .modal-buttons {
                flex-direction: column;
            }

            .modal-buttons .btn {
                width: 100%;
            }
        }

        /* 透明模式下特定按钮的透明度效果 */
        body.transparent-mode .trash-category,
        body.transparent-mode #createNewBtn,
        body.transparent-mode #createCategoryBtn,
        body.transparent-mode #settingsMenuToggle,
        body.transparent-mode #toggleBatchActionsBtn,
        body.transparent-mode #toggleViewModeBtn {
            opacity: 0.6;
            transition: opacity 0.3s;
        }

        /* 透明模式下特定按钮悬停时的透明度效果 */
        body.transparent-mode .trash-category:hover,
        body.transparent-mode #createNewBtn:hover,
        body.transparent-mode #createCategoryBtn:hover,
        body.transparent-mode #settingsMenuToggle:hover,
        body.transparent-mode #toggleBatchActionsBtn:hover,
        body.transparent-mode #toggleViewModeBtn:hover {
            opacity: 1;
        }

        /* 批量操作切换按钮样式 */
        #toggleBatchActionsBtn {
            background-color: var(--primary-color);
            color: #121212;
        }

        /* 浅色模式下批量操作切换按钮文本颜色 */
        body.light-mode #toggleBatchActionsBtn {
        background-color: #64b5f6; /* 将背景色设置为黑夜模式的主色调 */
        color: #121212; /* 将文本颜色设置为黑夜模式的文本颜色 */
        }

        /* 自定义复选框样式 */
        input[type="checkbox"] {
            -webkit-appearance: none; 
            -moz-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px; 
            border: 2px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
            outline: none;
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
            flex-shrink: 0;
            margin: 0;
            display: inline-block;
            vertical-align: middle;
            box-sizing: border-box;
            background-color: var(--frosted-card-bg);
        }

        /* 复选框选中状态 */
        input[type="checkbox"]:checked {
            background-color: rgba(var(--primary-color-rgb), 0.7);
            border-color: rgba(var(--primary-color-rgb), 0.3);
        }

        /* 复选框选中状态的对勾图标 */
        input[type="checkbox"]:checked::before {
            content: '✔';
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            color: var(--background-color);
            line-height: 1;
        }

        /* 复选框悬停效果 */
        input[type="checkbox"]:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.2);
        }

        /* 复选框焦点效果 */
        input[type="checkbox"]:focus {
            box-shadow: 0 0 0 1px rgba(var(--primary-color-rgb), 0.5);
        }


        /* 浅色模式下复选框选中状态的背景色 */
        body.light-mode input[type="checkbox"]:checked {
            background-color: rgba(100, 181, 246, 0.7); 
            border-color: rgba(100, 181, 246, 0.3); 
        }
        /* 浅色模式下复选框选中状态的对勾颜色 */
        body.light-mode input[type="checkbox"]:checked::before {
            color: #121212;
        }

        /* 卡片内文章复选框样式 */
        .card .article-checkbox {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 10;
        }

        /* 全选复选框容器样式 */
        #selectAllCheckboxContainer {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        /* 全选复选框标签样式 */
        #selectAllCheckboxContainer label {
            cursor: pointer;
        }

        /* New fixed sidebar for edit actions */
        .edit-actions-fixed-sidebar {
            position: fixed;
            top: 200px; /* Example: below header, adjust as needed */
            right: 0px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 5px;
            background-color: var(--frosted-card-bg);
            border: 1px solid var(--frosted-border);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 999;
            display: none; /* Hidden by default */
            width: 40px; /* Adjusted width to better fit buttons */
            align-items: center; /* Center buttons horizontally in column layout */
        }

        /* Adjust button padding for these specific buttons */
        .edit-actions-fixed-sidebar .btn {
            padding: 5px 5px;
            margin-right: 0; /* Set right margin to 0 */
            font-size: 11px; /* Shrink font size */
        }

        /* Scroll to Top button style */
        .btn-scroll-to-top {
            background-color: transparent !important; /* 强制背景透明 */
            border: none !important; /* 强制无边框 */
            color: var(--light-text); /* 使用浅色文本颜色，以便在不同背景下可见 */
            box-shadow: none !important; /* 移除阴影 */
            opacity: 0.6; /* 默认透明度，与透明模式下其他按钮保持一致 */
            transition: opacity 0.3s; /* 添加过渡效果 */
        }
        .btn-scroll-to-top:hover {
            background-color: transparent !important; /* 悬停时也保持透明 */
            opacity: 1; /* 悬停时完全不透明 */
            color: var(--primary-color); /* 悬停时文本颜色变为主题主色 */
        }
        /* 浅色模式下的回到顶部按钮 */
        body.light-mode .btn-scroll-to-top {
            background-color: transparent !important;
            border: none !important;
            color: var(--light-text); /* 浅色模式下也使用浅色文本 */
        }
        body.light-mode .btn-scroll-to-top:hover {
            background-color: transparent !important;            
            opacity: 1;
            color: var(--primary-color);
        }
        /* 确保在透明模式下也正确应用 */
        body.transparent-mode .btn-scroll-to-top {
            background-color: transparent !important;
            border: none !important;
            box-shadow: none !important;
            opacity: 0.6;
        }
        body.transparent-mode .btn-scroll-to-top:hover {
            background-color: transparent !important;
            opacity: 1;
            color: var(--primary-color);
        }
        /* Scroll to Bottom button style */
        .btn-scroll-to-bottom {
            background-color: transparent !important; /* 强制背景透明 */
            border: none !important; /* 强制无边框 */
            color: var(--light-text); /* 使用浅色文本颜色，以便在不同背景下可见 */
            box-shadow: none !important; /* 移除阴影 */
            opacity: 0.6; /* 默认透明度，与透明模式下其他按钮保持一致 */
            transition: opacity 0.3s; /* 添加过渡效果 */
        }
        .btn-scroll-to-bottom:hover {
            background-color: transparent !important; /* 悬停时也保持透明 */
            opacity: 1; /* 悬停时完全不透明 */
            color: var(--primary-color); /* 悬停时文本颜色变为主题主色 */
        }
        /* 浅色模式下的回到底部按钮 */
        body.light-mode .btn-scroll-to-bottom {
            background-color: transparent !important;
            border: none !important;
            color: var(--light-text); /* 浅色模式下也使用浅色文本 */
        }
        body.light-mode .btn-scroll-to-bottom:hover {
            background-color: transparent !important;
            opacity: 1;
            color: var(--primary-color);
        }
        /* 确保在透明模式下也正确应用 */
        body.transparent-mode .btn-scroll-to-bottom {
            background-color: transparent !important;
            border: none !important;
            box-shadow: none !important;
            opacity: 0.6;
        }
        body.transparent-mode .btn-scroll-to-bottom:hover {
            background-color: transparent !important;
            opacity: 1;
            color: var(--primary-color);
        }
        /* Media queries for responsiveness */
        @media (max-width: 768px) {
            .edit-actions-fixed-sidebar {
                position: static; /* Change to static to flow with content */
                width: auto; /* Allow content to determine width */
                right: auto;
                top: auto;
                transform: none;
                margin: 20px auto; /* Center horizontally */
                padding: 10px;
                flex-direction: row; /* Buttons side-by-side on small screens */
                justify-content: center;
                flex-wrap: wrap;
            }
        }

        /* Transparent mode for new sidebar */
        body.transparent-mode .edit-actions-fixed-sidebar {
            background-color: transparent !important;
            border-color: transparent !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        /* Adjust the label for content to not take up space */
        .article-detail-container label {
            flex-shrink: 0; /* Prevent labels from shrinking */
            margin-bottom: 5px; /* Keep margin below label */
        }
        /* Specific style for form field groups to ensure proper layout */
        .form-field-group {
            flex: 1; /* Allow it to take available space */
            min-width: 150px; /* Same as other form-header-row children */
            display: flex;
            flex-direction: column;
        }
        .form-field-group input[type="datetime-local"] {
            width: 100%; /* Ensure it takes full width of its container */
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Illusion</h1>
            <!-- 主题切换按钮 -->
            <button id="themeToggle" class="btn">切换模式</button>
            <!-- 视图模式切换按钮 (卡片/列表) -->
            <button id="toggleViewModeBtn" class="btn icon-btn"></button>

            <!-- 设置菜单容器 -->
            <div class="settings-menu-container">
                <!-- 设置菜单切换按钮 -->
                <button id="settingsMenuToggle" class="btn icon-btn">⚙</button>
                <!-- 设置下拉菜单内容 -->
                <div id="settingsDropdownMenu" class="settings-dropdown-content">
                    <div class="combined-settings-buttons">
                        <!-- 隐藏的文件输入框，用于选择背景图片 -->
                        <input type="file" id="backgroundImageInput" accept="image/*" style="display: none;">
                        <!-- 设置背景按钮 -->
                        <button id="setBgButton" class="btn">设置背景</button>
                        <!-- 清除背景按钮 -->
                        <button id="clearBackgroundBtn" class="btn cancel-btn-bright">清除背景</button>
                        <!-- 提示按钮 -->
                        <button id="tipBtn" class="btn">💡</button>
                        <!-- 透明模式切换按钮 -->
                        <button id="toggleTransparencyBtn" class="btn"></button>
                    </div>
                    <div class="search-bar-in-menu">
                        <!-- 搜索输入框 -->
                        <input type="text" id="searchInput" placeholder="标题/内容/简介...">
                        <!-- 搜索按钮 -->
                        <button id="searchBtn">🔎</button>
                    </div>
                </div>
            </div>
        </header>

        <main>
            <!-- 侧边栏 -->
            <aside class="sidebar">
                <!-- 分类标题 -->
                <h3 id="categoryHeading">作品分类</h3>
                <!-- 分类列表，由 JavaScript 动态加载 -->
                <ul class="categories">
                    <!-- Categories will be dynamically loaded here by JavaScript -->
                </ul>
                <!-- 创建新文章按钮 -->
                <a href="#" class="sidebar-new-btn" id="createNewBtn">创建新文章</a>
                <!-- 创建新分类按钮 -->
                <button class="sidebar-new-btn" id="createCategoryBtn">创建新分类</button>
                <!-- 完成排序按钮 (排序模式下显示) -->
                <button class="sidebar-new-btn" id="exitSortingModeBtn">完成排序</button>
                <!-- 批量操作切换按钮 -->
                <button class="sidebar-new-btn" id="toggleBatchActionsBtn">批量操作</button>

                <!-- 实际的批量操作区域，默认隐藏 -->
                <div id="actualBatchActions" class="batch-actions" style="display: none;">
                    <!-- 全选复选框 -->
                    <div style="display: flex; align-items: center; gap: 5px;" id="selectAllCheckboxContainer">
                        <input type="checkbox" id="selectAllCheckbox">
                        <label for="selectAllCheckbox" style="color: var(--light-text); font-size: 14px;">全选</label>
                    </div>
                    <!-- 批量删除按钮 -->
                    <button id="batchDeleteBtn" class="btn permanent-delete-btn">删除</button>
                    <!-- 重分类选择下拉框 -->
                    <select id="recategorizeSelect" class="btn" style="background-color: var(--card-background); color: var(--text-color); border: 1px solid var(--border-color);">
                        <option value="">选择新分类</option>
                        <!-- Categories will be dynamically loaded here -->
                    </select>
            </div>
            </aside>

            <!-- 主内容区域 -->
            <div id="mainView" class="content-area">
                <!-- 回收站通知，默认隐藏 -->
                <div id="trashNotification" class="trash-notification" style="display: none;">
                    <strong>回收站提示</strong>
                    <p>您正在查看回收站中的文章。这些文章将在30天后自动永久删除。</p>
                    <div class="trash-actions">
                        <!-- 全部恢复按钮 -->
                        <button id="batchRestoreAllBtn" class="btn restore-btn">全部恢复</button>
                        <!-- 清空回收站按钮 -->
                        <button id="emptyTrashBtn" class="btn permanent-delete-btn">清空回收站</button>
                    </div>
                </div>

                <!-- 内容头部，包含列表模式和详情模式的控制按钮 -->
                <div class="content-header">
                    <!-- 列表模式控制区域 -->
                    <div id="listModeControls" style="width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px;">
                        <!-- 批量恢复按钮 (回收站模式下显示) -->
                        <button id="batchRestore" class="btn restore-btn" style="display: none;">全部恢复</button>
                    </div>
                    <!-- 详情模式控制区域，默认隐藏 -->
                    <div id="detailModeControls" style="display: none;">
                        <!-- Back button will be dynamically added here -->
                    </div>
                </div>

                <!-- 文章容器，由 JavaScript 动态生成文章卡片 -->
                <div id="articlesContainer" class="card-container">
                    <!-- Articles will be dynamically generated here -->
                </div>

                <!-- 分页器，由 JavaScript 动态生成 -->
                <div class="pagination" id="pagination">
                    <!-- Pagination will be dynamically generated here -->
                </div>
            </div>
        </main>

        <!-- 通知消息框 -->
        <div class="notification" id="notification">
            <div id="notificationMessage"></div>
        </div>
    </div>
    <!-- New fixed sidebar for edit actions -->
    <div id="editActionsFixedSidebar" class="edit-actions-fixed-sidebar">
        <!-- Buttons will be dynamically added here -->
    </div>
    <!-- 创建新分类/提示信息的模态框 -->
    <div id="newCategoryModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="newCategoryModalTitle">创建新分类</h2>
            <p id="modalMessageP" style="display: none;"></p>
            <input type="text" id="newCategoryInput" placeholder="请输入新分类名称">
            <div class="modal-buttons">
                <button id="confirmNewCategoryBtn" class="btn">确认</button>
                <button id="cancelNewCategoryBtn" class="btn cancel-btn-bright">取消</button>
            </div>
        </div>
    </div>

    <!-- 密码输入模态框 -->
    <div id="passwordPromptModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="passwordModalTitle">文章已加密</h2>
            <p id="passwordModalMessage">输入6位数字密码以查看和编辑。</p>
            <input type="password" id="passwordInputPrompt" placeholder="请输入6位数字密码" maxlength="6" pattern="\d{6}" inputmode="numeric">
            <div class="modal-buttons">
                <button id="confirmPasswordPromptBtn" class="btn">确认</button>
                <button id="cancelPasswordPromptBtn" class="btn cancel-btn-bright">取消</button>
            </div>
        </div>
    </div>

    <script>
        // 全局状态变量
        let currentView = '全部作品'; // 初始视图设置为 '全部作品'
        let selectedArticleIds = []; // 存储当前选中的文章 ID
        let isViewingArticle = false; // 是否正在查看单篇文章详情
        let currentArticleId = null; // 当前查看的文章 ID
        let currentPage = 1; // 当前页码
        const ARTICLES_PER_PAGE_CARD = 12; // 每页显示的文章数量 (卡片模式)
        const ARTICLES_PER_PAGE_LIST = 6; // 每页显示的文章数量 (列表模式)
        let isLightMode = false; // 是否为浅色模式
        let isSortingCategories = false; // 是否处于分类排序模式
        let articleToProcess = null; // 待处理的文章对象 (加密/解密/编辑)
        let isTransparentMode = false; // 是否为透明模式
        let currentViewMode = 'card'; // 当前文章显示模式：'card' (卡片) 或 'list' (列表)
        let justSavedEncryptedArticle = false; // NEW: Flag to indicate if an article was just saved as encrypted
        let isBatchActionsVisible = false; // 新增：批量操作区域是否可见的标志

        const DEFAULT_CATEGORIES = ['草稿作', 'vestige', '文献材料']; // 默认分类
        let allCategories = []; // 所有分类，包括用户自定义的

        // DOM 元素快捷访问
        // 修改 D 函数，增加元素未找到时的警告
        const D = id => {
            const element = document.getElementById(id);
            if (!element) {
                console.warn(`Element with ID '${id}' not found. Please check your HTML or script execution order.`);
            }
            return element;
        }; // 通过 ID 获取元素
        const Q = sel => document.querySelector(sel); // 通过 CSS 选择器获取第一个元素
        const QA = sel => document.querySelectorAll(sel); // 通过 CSS 选择器获取所有元素

        // 常用 DOM 元素的引用
        const els = {
            articlesContainer: D('articlesContainer'), // 文章容器
            sidebar: Q('.sidebar'), // 侧边栏
            searchInput: D('searchInput'), // 搜索输入框
            searchBtn: D('searchBtn'), // 搜索按钮
            createNewBtn: D('createNewBtn'), // 创建新文章按钮
            emptyTrashBtn: D('emptyTrashBtn'), // 清空回收站按钮
            paginationContainer: D('pagination'), // 分页器容器
            themeToggleBtn: D('themeToggle'), // 主题切换按钮
            categoryHeading: D('categoryHeading'), // 分类标题
            categoriesList: Q('.categories'), // 分类列表
            exitSortingModeBtn: D('exitSortingModeBtn'), // 退出排序模式按钮
            createCategoryBtn: D('createCategoryBtn'), // 创建新分类按钮
            newCategoryModal: D('newCategoryModal'), // 新分类模态框
            newCategoryModalTitle: D('newCategoryModalTitle'), // 新分类模态框标题
            newCategoryInput: D('newCategoryInput'), // 新分类输入框
            confirmNewCategoryBtn: D('confirmNewCategoryBtn'), // 确认新分类按钮
            cancelNewCategoryBtn: D('cancelNewCategoryBtn'), // 取消新分类按钮
            passwordPromptModal: D('passwordPromptModal'), // 密码提示模态框
            passwordInputPrompt: D('passwordInputPrompt'), // 密码输入框
            confirmPasswordPromptBtn: D('confirmPasswordPromptBtn'), // 确认密码按钮
            cancelPasswordPromptBtn: D('cancelPasswordPromptBtn'), // 取消密码按钮
            passwordModalTitle: D('passwordModalTitle'), // 密码模态框标题
            passwordModalMessage: D('passwordModalMessage'), // 密码模态框消息
            listModeControls: D('listModeControls'), // 列表模式控制区域
            detailModeControls: D('detailModeControls'), // 详情模式控制区域
            selectAllCheckboxContainer: D('selectAllCheckboxContainer'), // 全选复选框容器
            selectAllCheckbox: D('selectAllCheckbox'), // 全选复选框
            batchDeleteBtn: D('batchDeleteBtn'), // 批量删除按钮
            recategorizeSelect: D('recategorizeSelect'), // 重分类选择下拉框
            batchRestoreBtn: D('batchRestore'), // 批量恢复按钮
            trashNotification: D('trashNotification'), // 回收站通知
            toggleBatchActionsBtn: D('toggleBatchActionsBtn'), // 批量操作切换按钮
            actualBatchActions: D('actualBatchActions'), // 实际批量操作区域
            backgroundImageInput: D('backgroundImageInput'), // 背景图片文件输入
            setBgButton: D('setBgButton'), // 设置背景按钮
            clearBackgroundBtn: D('clearBackgroundBtn'), // 清除背景按钮
            settingsMenuToggle: D('settingsMenuToggle'), // 设置菜单切换按钮
            settingsDropdownMenu: D('settingsDropdownMenu'), // 设置下拉菜单
            tipBtn: D('tipBtn'), // 提示按钮
            toggleTransparencyBtn: D('toggleTransparencyBtn'), // 透明模式切换按钮
            toggleViewModeBtn: D('toggleViewModeBtn'), // 视图模式切换按钮
            modalMessageP: D('modalMessageP'), // 模态框消息段落
            notification: D('notification'), // 通知消息框
            notificationMessage: D('notificationMessage'), // 通知消息内容
            editActionsFixedSidebar: D('editActionsFixedSidebar'), // New fixed sidebar for edit actions
            batchRestoreAllBtn: D('batchRestoreAllBtn') // 回收站の全部恢复按钮
        };

        let editorToolbarButtons = [];

        // --- 工具函数 ---

        /** 管理 localStorage 操作。 */
        const Storage = {
            /**
             * 从 localStorage 获取数据。
             * @param {string} key - 键名。
             * @param {*} defaultValue - 默认值，如果键不存在或解析失败则返回。
             * @returns {*} 存储的值或默认值。
             */
            get: (key, defaultValue = null) => {
                try {
                    const item = localStorage.getItem(key);
                    return item ? JSON.parse(item) : defaultValue;
                } catch (e) {
                    console.error(`Error getting item from localStorage for key "${key}":`, e);
                    return defaultValue;
                }
            },
            /**
             * 将数据存储到 localStorage。
             * @param {string} key - 键名。
             * @param {*} value - 要存储的值。
             */
            set: (key, value) => {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                } catch (e) {
                    console.error(`Error setting item to localStorage for key "${key}":`, e);
                }
            },
            /**
             * 从 localStorage 移除数据。
             * @param {string} key - 键名。
             */
            remove: key => {
                try {
                    localStorage.removeItem(key);
                } catch (e) {
                    console.error(`Error removing item from localStorage for key "${key}":`, e);
                }
            },
            /** 获取文章列表。 */
            getArticles: () => Storage.get('articles', []),
            /** 保存文章列表。 */
            saveArticles: (articles) => Storage.set('articles', articles),
            /** 获取回收站文章列表。 */
            getTrashedArticles: () => Storage.get('trashedArticles', []),
            /** 保存回收站文章列表。 */
            saveTrashedArticles: (trashedArticles) => Storage.set('trashedArticles', trashedArticles),
            /** 获取用户分类列表。 */
            getCategories: () => Storage.get('userCategories', []),
            /** 保存用户分类列表。 */
            saveCategories: (categories) => Storage.set('userCategories', categories)
        };

        /**
         * 显示临时通知。
         * @param {string} message - 通知消息。
         * @param {'success'|'error'|'info'} type - 通知类型。
         */
        const showNotification = (message, type) => {
            // **修改开始**：添加对 els.notificationMessage 和 els.notification 的检查
            if (!els.notificationMessage || !els.notification) {
                console.error("Notification elements (notificationMessage or notification) are missing from the DOM. Cannot display notification.");
                return; // 如果元素不存在，则直接退出函数
            }
            // **修改结束**

            els.notificationMessage.textContent = message;
            els.notification.className = `notification ${type}`; // 设置通知类型
            els.notification.classList.add('show'); // 显示通知
            setTimeout(() => {
                // 在定时器回调中也进行检查，以防元素在延迟期间被移除
                if (els.notification) {
                    els.notification.classList.remove('show');
                }
            }, 3000); // 3秒后隐藏
        };

        /**
         * 将时间戳格式化为 datetime-local 输入框所需格式。
         * @param {number} ts - 时间戳。
         * @returns {string} 格式化后的字符串。
         */
        const formatTimestampForInput = ts => ts ? new Date(ts).toISOString().slice(0, 10) : '';

        /**
         * 将时间戳格式化为显示格式。
         * @param {number} ts - 时间戳。
         * @returns {string} 格式化后的本地时间字符串。
         */
        const formatTimestampForDisplay = ts => ts ? new Date(ts).toLocaleString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        }) : 'N/A';

        /**
         * 简单的 XOR 异或密码 (不用于安全敏感数据)。
         * @param {string} text - 原始文本。
         * @param {string} password - 6位数字密码。
         * @returns {string} 异或处理后的文本。
         */
        const _xorCipher = (text, password) => {
            if (!text || !password || password.length !== 6 || !/^\d{6}$/.test(password)) return text;
            let result = '';
            const passwordDigits = password.split('').map(Number); // 将密码转换为数字数组
            const keyLength = passwordDigits.length;
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i) & 0xFF; // 取字符的低8位
                const keyDigit = passwordDigits[i % keyLength]; // 循环使用密码数字
                result += String.fromCharCode(charCode ^ (keyDigit + 32)); // 异或操作并加上偏移量避免控制字符
            }
            return result;
        };

        /**
         * 使用 XOR 和 Base64 加密数据。
         * @param {string} data - 原始数据。
         * @param {string} password - 6位数字密码。
         * @returns {string} 加密后的 Base64 字符串。
         */
        const encryptData = (data, password) => {
            if (!data || !password || password.length !== 6 || !/^\d{6}$/.test(password)) return data;
            // 先进行 URI 编码，再转换为字节字符串，以处理多字节字符
            const utf8Encoded = encodeURIComponent(data).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1));
            return btoa(_xorCipher(utf8Encoded, password)); // Base64 编码
        };

        /**
         * 使用 XOR 和 Base64 解密数据。
         * @param {string} encryptedData - 加密后的 Base64 字符串。
         * @param {string} password - 6位数字密码。
         * @returns {string|null} 解密后的原始数据，如果解密失败则返回 null。
         */
        const decryptData = (encryptedData, password) => {
            if (!encryptedData || !password || password.length !== 6 || !/^\d{6}$/.test(password)) return null;
            try {
                const decodedBase64 = atob(encryptedData); // Base64 解码
                const xorResult = _xorCipher(decodedBase64, password); // XOR 解密
                // 将字节字符串转换回 URI 编码，再进行 URI 解码
                return decodeURIComponent(Array.from(xorResult).map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
            } catch (e) {
                console.error("Decryption failed:", e);
                return null;
            }
        };

        // --- 主题与背景管理 ---

        /** 应用保存的主题偏好。 */
        const applyThemePreference = () => {
            const savedTheme = localStorage.getItem('theme');
            isLightMode = savedTheme === 'light';
            document.body.classList.toggle('light-mode', isLightMode); // 切换 body 的 light-mode 类
            els.themeToggleBtn.textContent = isLightMode ? '✨' : '🌅'; // 更新按钮文本
        };

        /** 切换主题模式 (深色/浅色)。 */
        const toggleTheme = () => {
            isLightMode = !isLightMode;
            document.body.classList.toggle('light-mode', isLightMode);
            localStorage.setItem('theme', isLightMode ? 'light' : 'dark'); // 保存主题偏好
            els.themeToggleBtn.textContent = isLightMode ? '✨' : '🌅';
        };

        /** 应用保存的背景图片。 */
        const applySavedBackground = () => {
            const savedBackground = localStorage.getItem('backgroundImage');
            document.body.style.backgroundImage = savedBackground ? `url(${savedBackground})` : 'none';
        };

        /** 清除背景图片。 */
        const clearBackgroundImage = () => {
            document.body.style.backgroundImage = 'none';
            localStorage.removeItem('backgroundImage'); // 从 localStorage 移除
            showNotification('背景图片已清除', 'info');
        };

        /** 更新透明模式按钮的文本。 */
        const updateTransparencyButtonText = () => {
            if (els.toggleTransparencyBtn) {
                els.toggleTransparencyBtn.textContent = isTransparentMode ? '取消透明化' : '透明化';
                els.toggleTransparencyBtn.classList.toggle('cancel-btn-bright', isTransparentMode);
            }
        };

        /** 启用透明模式。 */
        const applyTransparency = () => {
            document.body.classList.add('transparent-mode');
            localStorage.setItem('transparentMode', 'true');
            isTransparentMode = true;
            showNotification('已启用透明模式', 'info');
            updateTransparencyButtonText();
        };

        /** 禁用透明模式。 */
        const removeTransparency = () => {
            document.body.classList.remove('transparent-mode');
            localStorage.removeItem('transparentMode');
            isTransparentMode = false;
            showNotification('已取消透明模式', 'info');
            updateTransparencyButtonText();
        };

        /** 应用保存的透明模式偏好。 */
        const applyTransparencyPreference = () => {
            isTransparentMode = localStorage.getItem('transparentMode') !== 'false';
            document.body.classList.toggle('transparent-mode', isTransparentMode);
            updateTransparencyButtonText();
        };

        /** 应用保存的视图模式偏好 (卡片/列表)。 */
        const applyViewModePreference = () => {
            currentViewMode = localStorage.getItem('viewMode') || 'card';
            els.articlesContainer.classList.toggle('list-mode', currentViewMode === 'list'); // 切换文章容器的类
            els.toggleViewModeBtn.textContent = currentViewMode === 'list' ? '▦' : '☰'; // 更新按钮图标
            els.toggleViewModeBtn.title = currentViewMode === 'list' ? '切换到卡片视图' : '切换到列表视图';
        };

        /** 切换视图模式。 */
        const toggleViewMode = () => {
            currentViewMode = currentViewMode === 'card' ? 'list' : 'card';
            localStorage.setItem('viewMode', currentViewMode); // 保存视图模式偏好
            applyViewModePreference(); // 应用新的视图模式
            loadArticles(); // 切换视图模式后重新加载文章以应用新的分页设置
        };

        // --- 分类管理 ---

        /** 加载并显示分类列表。 */
        const loadCategories = () => {
            allCategories = Storage.getCategories(); // 从 localStorage 获取用户自定义分类
            const categoriesSet = new Set(allCategories);
            DEFAULT_CATEGORIES.forEach(cat => categoriesSet.add(cat)); // 添加默认分类
            allCategories = Array.from(categoriesSet); // 去重并转回数组
            Storage.saveCategories(allCategories); // 保存整理后的分类列表

            els.categoriesList.innerHTML = ''; // 清空现有分类列表

            /**
             * 创建分类列表项 (li 元素)。
             * @param {string} cat - 分类名称。
             * @param {boolean} isSpecial - 是否为特殊分类 (如回收站)。
             * @returns {HTMLLIElement} 创建的 li 元素。
             */
            const createCategoryLi = (cat, isSpecial = false) => {
                const li = document.createElement('li');
                const link = document.createElement('a');
                link.href = '#';
                link.dataset.category = cat; // 存储分类名称
                link.textContent = cat;
                if (isSpecial) link.className = 'trash-category'; // 特殊分类添加样式
                li.appendChild(link);

                // 修正：确保“全部作品”分类在排序模式下也不可拖拽
                if (isSortingCategories && !isSpecial && cat !== '全部作品') { // 增加对 '全部作品' 的判断
                    li.classList.add('draggable');
                    li.setAttribute('draggable', 'true');
                }
                return li;
            };

            els.categoriesList.appendChild(createCategoryLi('全部作品', false)); // 添加“全部作品”
            allCategories.forEach(cat => els.categoriesList.appendChild(createCategoryLi(cat))); // 添加用户自定义分类
            els.categoriesList.appendChild(createCategoryLi('回收站', true)); // 添加“回收站”

            // 设置当前激活的分类样式
            QA('.categories li a').forEach(link => {
                link.classList.toggle('active', link.dataset.category === currentView);
            });

            attachCategoryLinkListeners(); // 绑定分类链接事件
            updateRecategorizeSelect(); // 更新重分类下拉框
        };

        /** 保存当前分类列表到 localStorage。 */
        const saveCategories = () => Storage.saveCategories(allCategories);

        /**
         * 添加新分类。
         * @param {string} name - 新分类名称。
         * @returns {boolean} 是否添加成功。
         */
        const addNewCategory = name => {
            name = name.trim();
            if (!name) {
                showNotification('分类名称不能为空', 'error');
                return false;
            }
            if (allCategories.some(cat => cat.toLowerCase() === name.toLowerCase())) { // 检查是否已存在
                showNotification('该分类已存在', 'error');
                return false;
            }
            allCategories.push(name); // 添加到数组
            saveCategories(); // 保存
            loadCategories(); // 重新加载分类列表
            showNotification(`分类 "${name}" 已创建`, 'success');
            return true;
        };

        /** 更新重分类下拉框的选项。 */
        const updateRecategorizeSelect = () => {
            els.recategorizeSelect.innerHTML = '<option value="">选择新分类</option>'; // 清空并添加默认选项
            allCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                els.recategorizeSelect.appendChild(option);
            });

        const updateBatchActionButtonsState = () => {
            const hasSelection = selectedArticleIds.length > 0; // 是否有文章被选中
            const hasTrashedArticles = Storage.getTrashedArticles().length > 0; // 回收站是否有文章

            if (els.toggleBatchActionsBtn) els.toggleBatchActionsBtn.style.display = 'block';

            if (currentView !== '回收站') {
                if (els.trashNotification) els.trashNotification.style.display = 'none';
                if (els.batchRestoreAllBtn) els.batchRestoreAllBtn.style.display = 'none'; // 确保在非回收站视图下隐藏
                if (els.emptyTrashBtn) els.emptyTrashBtn.style.display = 'none';

                if (els.batchDeleteBtn) {
                    els.batchDeleteBtn.textContent = '删除';
                    els.batchDeleteBtn.disabled = !hasSelection;
                }
                if (els.recategorizeSelect) {
                    els.recategorizeSelect.style.display = 'block';
                    els.recategorizeSelect.disabled = !hasSelection;
                }
                if (els.selectAllCheckboxContainer) els.selectAllCheckboxContainer.style.display = 'flex';

            } else { // 回收站视图
                if (els.trashNotification) els.trashNotification.style.display = 'block';

                // 新增：显示并控制“全部恢复”按钮的状态
                if (els.batchRestoreAllBtn) {
                    els.batchRestoreAllBtn.style.display = 'block'; // 显示按钮
                    els.batchRestoreAllBtn.disabled = !hasTrashedArticles; // 根据回收站是否有文章禁用
                }

                if (els.emptyTrashBtn) {
                    els.emptyTrashBtn.style.display = 'block';
                    els.emptyTrashBtn.disabled = !hasTrashedArticles;
                }

                if (els.batchDeleteBtn) {
                    els.batchDeleteBtn.textContent = '永久删除选中';
                    els.batchDeleteBtn.disabled = !hasSelection;
                }
                if (els.recategorizeSelect) {
                    els.recategorizeSelect.style.display = 'block';
                    els.recategorizeSelect.disabled = !hasSelection;
                }
                if (els.selectAllCheckboxContainer) els.selectAllCheckboxContainer.style.display = 'flex';
            }
        };

            // 只有在非回收站视图下才显示“创建新分类”选项
            if (currentView !== '回收站') { //  'trash' to '回收站'
                const createNewOption = document.createElement('option');
                createNewOption.value = 'create_new_category';
                createNewOption.textContent = '创建新分类';
                els.recategorizeSelect.appendChild(createNewOption); // 添加“创建新分类”选项
            }
        };

        /** 为分类链接绑定事件监听器。 */
        const attachCategoryLinkListeners = () => {
            QA('.categories li').forEach(li => {
                const link = li.querySelector('a');
                link.onclick = e => {
                    e.preventDefault();
                    if (isSortingCategories) return; // 排序模式下禁用点击
                    QA('.categories li a').forEach(l => l.classList.remove('active')); // 移除所有激活状态
                    link.classList.add('active'); // 设置当前链接为激活状态
                    currentView = link.dataset.category; // 更新当前视图
                    isViewingArticle = false;
                    currentArticleId = null;
                    currentPage = 1;
                    loadArticles(); // 加载文章
                    hideAllDeleteButtons(); // 隐藏所有删除按钮
                };
                li.onmouseenter = () => { // 鼠标进入时显示删除按钮
                    if (isSortingCategories) return;
                    showDeleteButton(link);
                };
                li.onmouseleave = hideAllDeleteButtons; // 鼠标离开时隐藏删除按钮
            });
        };

        /**
         * 显示指定分类的删除按钮。
         * @param {HTMLElement} targetLink - 目标分类链接元素。
         */
        const showDeleteButton = targetLink => {
            const categoryName = targetLink.dataset.category;
            // 默认分类和特殊分类不可删除
            if (categoryName === '全部作品' || categoryName === '回收站' || DEFAULT_CATEGORIES.includes(categoryName)) return;
            // MODIFIED: 'trash' to '回收站'

            hideAllDeleteButtons(); // 先隐藏所有其他删除按钮
            const listItem = targetLink.closest('li');
            let deleteBtn = listItem.querySelector('.category-delete-btn');

            if (!deleteBtn) { // 如果不存在，则创建
                deleteBtn = document.createElement('button');
                deleteBtn.className = 'category-delete-btn';
                deleteBtn.textContent = '×';
                deleteBtn.title = `删除分类: ${categoryName}`;
                deleteBtn.onclick = e => {
                    e.stopPropagation(); // 阻止事件冒泡
                    deleteCategory(categoryName); // 调用删除分类函数
                };
                listItem.appendChild(deleteBtn);
            }
            deleteBtn.style.display = 'flex'; // 显示删除按钮
        };

        /** 隐藏所有分类删除按钮。 */
        const hideAllDeleteButtons = () => {
            QA('.category-delete-btn').forEach(btn => btn.style.display = 'none');
        };

        /**
         * 删除分类。
         * @param {string} name - 要删除的分类名称。
         */
        const deleteCategory = name => {
            allCategories = allCategories.filter(cat => cat !== name); // 从分类列表中移除
            saveCategories(); // 保存分类

            let articles = Storage.getArticles();
            let trashedArticles = Storage.getTrashedArticles();

            // 处理文章，将属于被删除分类的文章移动到“草稿作”
            const processArticles = arr => arr.map(article => {
                if (article.category === name) {
                    article.category = '草稿作';
                    // 如果是“文献材料”分类被删除，则清空相关文献字段
                    if (name === '文献材料') {
                        article.journal = article.year = article.impactFactor = article.citation = '';
                    }
                    // 如果文章已加密，则清空其描述（防止泄露）
                    article.description = article.isEncrypted ? encryptData('', '000000') : '';
                }
                return article;
            });

            Storage.saveArticles(processArticles(articles));
            Storage.saveTrashedArticles(processArticles(trashedArticles));

            showNotification(`分类 "${name}" 已删除，相关文章已移至 "草稿作"`, 'success');
            loadCategories(); // 重新加载分类列表
            loadArticles(); // 重新加载文章
        };

        // --- 文章的 CRUD (创建、读取、更新、删除) 与显示 ---

        /**
         * 生成并显示文章卡片。
         * @param {Array<Object>} articles - 文章数组。
         */
        const generateArticleCards = articles => {
            els.articlesContainer.innerHTML = ''; // 清空文章容器
            if (articles.length === 0) {
                els.articlesContainer.innerHTML = '<p>没有找到文章</p>';
                return;
            }

        /**
         * 切换文章的置顶状态并重新排序列表。
         * @param {number} id - 要置顶/取消置顶的文章 ID。
         */
        const togglePinArticle = id => {
            // 获取当前文章列表 (只处理非回收站的文章)
            let articles = Storage.getArticles();
            const articleIndex = articles.findIndex(a => a.id === parseInt(id));

            if (articleIndex !== -1) {
                const article = articles[articleIndex];
                article.isPinned = !article.isPinned; // 切换置顶状态

                // 重新排序文章：置顶文章在前，然后按创建日期降序排列
                articles.sort((a, b) => {
                    // 置顶文章优先
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;

                    // 如果置顶状态相同，则按创建日期（最新在前）排序
                    const aCreatedAt = a.createdAt || 0;
                    const bCreatedAt = b.createdAt || 0;
                    return bCreatedAt - aCreatedAt;
                });

                Storage.saveArticles(articles); // 保存更新后的文章列表
                showNotification(article.isPinned ? '文章已置顶' : '文章已取消置顶', 'success');
                loadArticles(); // 重新加载文章以反映新的顺序和状态
            }
        };

            articles.forEach(article => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.id = article.id; // 存储文章 ID

                // 新增: 如果文章已置顶，添加 'pinned' 类
                if (article.isPinned) {
                    card.classList.add('pinned');
                }

                // 无论是否在回收站视图，都显示复选框
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'article-checkbox';
                checkbox.dataset.id = article.id; // 存储文章 ID
                checkbox.id = `article-checkbox-${article.id}`; // 为复选框本身设置唯一 ID
                checkbox.checked = selectedArticleIds.includes(article.id); // 根据选中状态设置
                checkbox.onclick = e => e.stopPropagation(); // 阻止事件冒泡，避免点击复选框时触发卡片点击
                checkbox.onchange = () => updateSelectedArticles(article.id, checkbox.checked); // 监听选中状态变化
                card.appendChild(checkbox);

                // 新增: 置顶按钮
                const pinBtn = document.createElement('button');
                pinBtn.className = 'pin-btn';
                pinBtn.innerHTML = article.isPinned ? '📌' : '📍'; // 根据置顶状态显示不同图标
                pinBtn.title = article.isPinned ? '取消置顶' : '置顶文章';
                if (article.isPinned) {
                    pinBtn.classList.add('pinned-active'); // 如果已置顶，添加激活样式
                }
                pinBtn.onclick = e => {
                    e.stopPropagation(); // 阻止事件冒泡，避免点击置顶按钮时触发卡片点击
                    togglePinArticle(article.id); // 调用置顶/取消置顶函数
                };
                card.appendChild(pinBtn); // 将置顶按钮添加到卡片中

                const title = document.createElement('h3');
                title.className = 'card-title';
                title.textContent = article.isEncrypted ? '🔒 已加密文章' : article.title; // 加密文章显示特殊标题

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'card-content-wrapper';

                const text = document.createElement('p');
                text.className = 'card-text';
                if (article.isEncrypted) {
                    text.textContent = '此文章已加密，点击查看详情并输入密码。';
                } else if (article.category === '文献材料') { // 文献材料显示特定元信息
                    text.innerHTML = `期刊: ${article.journal || ''}<br>年份: ${article.year || ''}<br>影响因子: ${article.impactFactor || ''}<br>引用: ${article.citation || ''}`;
                } else {
                    text.textContent = article.description;
                }

                const metaRight = document.createElement('div');
                metaRight.className = 'card-meta-right';
                const category = document.createElement('span');
                category.textContent = article.category;
                metaRight.append(category);
                // Only append date if article.showCreatedAt is not explicitly false
                if (article.showCreatedAt !== false) {
                    const date = document.createElement('span');
                    date.textContent = article.date;
                    metaRight.append(date);
                }
                contentWrapper.append(text, metaRight);

                const actions = document.createElement('div');
                actions.className = 'card-actions';

                if (currentView === '回收站') { // MODIFIED: 'trash' to '回收站' // 回收站视图显示恢复和永久删除按钮
                    const restoreBtn = document.createElement('button');
                    restoreBtn.className = 'action-btn';
                    restoreBtn.textContent = '恢复';
                    restoreBtn.onclick = e => {
                        e.stopPropagation();
                        restoreFromTrash(article.id);
                    };
                    const permanentDeleteBtn = document.createElement('button');
                    permanentDeleteBtn.className = 'action-btn';
                    permanentDeleteBtn.textContent = '永久删除';
                    permanentDeleteBtn.onclick = e => {
                        e.stopPropagation();
                        permanentDelete(article.id);
                    };
                    actions.append(restoreBtn, permanentDeleteBtn);
                } else { // 其他视图显示编辑和删除按钮
                    const editBtn = document.createElement('button');
                    editBtn.className = 'action-btn';
                    editBtn.textContent = '编辑';
                    editBtn.onclick = e => {
                        e.stopPropagation();
                        editArticle(article.id);
                    };
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'action-btn';
                    deleteBtn.textContent = '删除';
                    deleteBtn.onclick = e => {
                        e.stopPropagation();
                        moveToTrash(article.id);
                    };
                    actions.append(editBtn, deleteBtn);
                }

                card.append(title, contentWrapper, actions);
                card.onclick = e => { // 点击卡片查看详情 (排除点击复选框和按钮)
                    if (!['INPUT', 'BUTTON'].includes(e.target.tagName) && !e.target.closest('.action-btn')) {
                        viewArticle(article.id);
                    }
                };
                els.articlesContainer.appendChild(card);
            });
        };

        /**
         * 显示文章详情（操作按钮移到右侧栏）
         * @param {Object} article - 文章对象。
         */
        const displayArticleDetails = article => {
            // 确保主内容区域和右侧栏都显示
            els.sidebar.style.display = 'none';
            isViewingArticle = true;
            currentArticleId = article.id;

            els.listModeControls.style.display = 'none';
            els.detailModeControls.style.display = 'none';
            els.detailModeControls.innerHTML = '';
            Q('.content-header').classList.add('has-bottom-border');

            els.toggleViewModeBtn.style.display = 'none';
            els.paginationContainer.style.display = 'none';

            // 修复：右侧栏操作按钮显示
            els.editActionsFixedSidebar.innerHTML = '';
            els.editActionsFixedSidebar.style.display = 'flex';

            // 返回按钮
            const backButton = document.createElement('button');
            backButton.className = 'btn btn-primary-blue';
            backButton.textContent = '返回';
            backButton.title = '返回文章列表'; 
            backButton.onclick = () => {
                els.editActionsFixedSidebar.style.display = 'none';
                isViewingArticle = false;
                currentArticleId = null;
                currentPage = 1;
                // 修复：恢复侧边栏显示
                els.sidebar.style.display = 'block';
                els.toggleViewModeBtn.style.display = 'block';
                els.paginationContainer.style.display = 'block';
                loadArticles();
            };

            // 编辑按钮
            const editButton = document.createElement('button');
            editButton.className = 'btn';
            editButton.textContent = '✍';
            editButton.title = '编辑文章'; 
            editButton.onclick = () => editArticle(article.id);

            // 加密/解密按钮
            const encryptDecryptButton = document.createElement('button');
            encryptDecryptButton.className = 'btn';
            if (article.isEncrypted) {
                encryptDecryptButton.textContent = '🔓解锁';
                encryptDecryptButton.title = '解锁文章'; 
                encryptDecryptButton.onclick = () => {
                    articleToProcess = article;
                    els.passwordPromptModal.dataset.actionType = 'decrypt';
                    showPasswordPrompt();
                };
            } else {
                encryptDecryptButton.textContent = '🔒';
                encryptDecryptButton.title = '加密文章'; 
                encryptDecryptButton.onclick = () => {
                    articleToProcess = article;
                    els.passwordPromptModal.dataset.actionType = 'encrypt';
                    showPasswordPrompt();
                };
            }

            // 删除按钮（始终显示，无论视图）
            const deleteButton = document.createElement('button');
            deleteButton.className = 'btn permanent-delete-btn';
            deleteButton.textContent = '🎇';
            deleteButton.title = '删除文章';
            deleteButton.onclick = () => moveToTrash(article.id);

            // 回到顶部按钮
            const scrollToTopButton = document.createElement('button');
            scrollToTopButton.className = 'btn btn-scroll-to-top';
            scrollToTopButton.textContent = '🔺';
            scrollToTopButton.title = '回到顶部';
            scrollToTopButton.onclick = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            // 回到底部按钮 (NEW)
            const scrollToBottomButton = document.createElement('button');
            scrollToBottomButton.className = 'btn btn-scroll-to-bottom'; // Use a new class
            scrollToBottomButton.textContent = '🔻';
            scrollToBottomButton.title = '跳到底部';
            scrollToBottomButton.onclick = () => {
                window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
            };

            // 按钮顺序：返回、编辑、加密/解密、删除、回到顶部
            els.editActionsFixedSidebar.append(scrollToBottomButton, backButton, editButton, encryptDecryptButton, deleteButton, scrollToTopButton);

            // 主内容区域显示文章详情
            els.articlesContainer.innerHTML = '';
            const articleDetail = document.createElement('div');
            articleDetail.className = 'article-detail-container';

            // 文章头部（标题和元信息）
            const articleHeader = document.createElement('div');
            articleHeader.className = 'article-header-container';
            const title = document.createElement('h2');
            title.textContent = article.isEncrypted ? '🔒 已加密文章' : article.title;
            const meta = document.createElement('div');
            meta.className = 'article-meta-container';
            const category = document.createElement('span');
            category.textContent = `分类: ${article.category}`;
            meta.append(category);
            if (article.showCreatedAt !== false) {
                const date = document.createElement('span');
                date.textContent = article.date;
                meta.append(date);
            }
            articleHeader.append(title, meta);

            // 文章描述（或文献信息）
            const description = document.createElement('p');
            description.className = 'article-description-container';
            if (article.category === '文献材料') {
                description.innerHTML = `期刊: ${article.journal || 'N/A'}<br>年份: ${article.year || 'N/A'}<br>影响因子: ${article.impactFactor || 'N/A'}<br>引用: ${article.citation || 'N/A'}`;
            } else {
                description.textContent = article.isEncrypted ? '此文章已加密，点击解锁按钮输入密码查看内容。' : article.description;
            }
            // 新增内容容器
            const content = document.createElement('div');
            content.className = 'article-content-container';
            if (article.isEncrypted) {
                content.innerHTML = '<p>内容已加密。</p>';
            } else {
                content.innerHTML = article.content || '';
            }

            // 显示字数与预计阅读时间
            if (article.showWordCount) {
                // 统计纯文本字数
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = article.content || '';
                const plainText = tempDiv.textContent || '';
                const wordCount = plainText.replace(/\s/g, '').length;
                const readMinutes = Math.max(1, Math.ceil(wordCount / 300));
                const wordCountInfo = document.createElement('div');
                wordCountInfo.style.cssText = 'color: var(--light-text); font-size: 13px; margin-bottom: 10px; text-align: right;';
                wordCountInfo.textContent = `字数：${wordCount}，预计阅读时间：${readMinutes}分钟`;
                articleDetail.append(articleHeader, description, wordCountInfo, content);
            } else {
                articleDetail.append(articleHeader, description, content);
            }
            els.articlesContainer.appendChild(articleDetail);
        };

        /**
         * 显示加密文章的占位符详情（操作按钮移到右侧栏）
         * @param {Object} article - 加密文章对象。
         */
        const displayEncryptedArticlePlaceholder = article => {
            // 修复：确保主内容区域和右侧栏都显示
            els.sidebar.style.display = 'none';
            isViewingArticle = true;
            currentArticleId = article.id;

            els.listModeControls.style.display = 'none';
            els.detailModeControls.style.display = 'none';
            els.detailModeControls.innerHTML = '';

            els.toggleViewModeBtn.style.display = 'none';
            els.paginationContainer.style.display = 'none';

            // 修复：右侧栏操作按钮显示
            els.editActionsFixedSidebar.innerHTML = '';
            els.editActionsFixedSidebar.style.display = 'flex';

            // 返回按钮
            const backButton = document.createElement('button');
            backButton.className = 'btn btn-primary-blue';
            backButton.textContent = '返回';
            backButton.onclick = () => {
                els.editActionsFixedSidebar.style.display = 'none';
                isViewingArticle = false;
                currentArticleId = null;
                currentPage = 1;
                // 修复：恢复侧边栏显示
                els.sidebar.style.display = 'block';
                els.toggleViewModeBtn.style.display = 'block';
                els.paginationContainer.style.display = 'block';
                loadArticles();
            };

            // 解锁按钮
            const decryptButton = document.createElement('button');
            decryptButton.className = 'btn';
            decryptButton.textContent = '🔓 解锁';
            decryptButton.title = '解锁文章'; 
            decryptButton.onclick = () => {
                articleToProcess = article;
                els.passwordPromptModal.dataset.actionType = 'decrypt';
                showPasswordPrompt();
            };

            // 删除按钮（始终显示，无论视图）
            const deleteButton = document.createElement('button');
            deleteButton.className = 'btn permanent-delete-btn';
            deleteButton.textContent = '🎇';
            deleteButton.onclick = () => moveToTrash(article.id);

            // 回到顶部按钮
            const scrollToTopButton = document.createElement('button');
            scrollToTopButton.className = 'btn btn-scroll-to-top';
            scrollToTopButton.textContent = '🔺';
            scrollToTopButton.title = '回到顶部';
            scrollToTopButton.onclick = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            // 回到底部按钮 (NEW)
            const scrollToBottomButton = document.createElement('button');
            scrollToBottomButton.className = 'btn btn-scroll-to-bottom'; // Use a new class
            scrollToBottomButton.textContent = '🔻';
            scrollToBottomButton.title = '跳到底部';
            scrollToBottomButton.onclick = () => {
                window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
            };

            els.editActionsFixedSidebar.append(scrollToBottomButton, backButton, decryptButton, deleteButton, scrollToTopButton);

            // 主内容区域显示加密文章占位符
            els.articlesContainer.innerHTML = '';
            const articleDetail = document.createElement('div');
            articleDetail.className = 'article-detail-container';

            // 文章头部（加密标题）
            const articleHeader = document.createElement('div');
            articleHeader.className = 'article-header-container';
            const title = document.createElement('h2');
            title.textContent = '🔒 已加密文章';
            const meta = document.createElement('div');
            meta.className = 'article-meta-container';
            const category = document.createElement('span');
            category.textContent = `分类: ${article.category}`;
            meta.append(category);
            if (article.showCreatedAt !== false) {
                const createdAt = document.createElement('span');
                createdAt.textContent = `创建日期: ${formatTimestampForDisplay(article.createdAt)}`;
                meta.append(createdAt);
            }
            articleHeader.append(title, meta);

            // 加密消息提示
            const encryptedMessage = document.createElement('p');
            encryptedMessage.className = 'article-description-container';
            encryptedMessage.style.fontStyle = 'normal';
            encryptedMessage.textContent = '此文章已加密，请点击解锁按钮输入密码。';

            // 内容占位符
            const contentPlaceholder = document.createElement('div');
            contentPlaceholder.className = 'article-content-container';
            contentPlaceholder.innerHTML = '<p>内容已加密。</p>';

            articleDetail.append(articleHeader, encryptedMessage, contentPlaceholder);
            els.articlesContainer.appendChild(articleDetail);
        };

        /**
         * 显示文章详情 (处理加密文章)。
         * @param {number} id - 文章 ID。
         */
        const viewArticle = id => {
            const articles = currentView === '回收站' ? Storage.getTrashedArticles() : Storage.getArticles(); // MODIFIED: 'trash' to '回收站'
            const article = articles.find(a => a.id === parseInt(id));
            if (!article) {
                showNotification('未找到该文章', 'error');
                isViewingArticle = false;
                currentArticleId = null;
                currentPage = 1;
                loadArticles(); // If article not found, go back to list
                return;
            }

            articleToProcess = article; // Set current article to process

            // Check if this article was just saved and encrypted
            const wasJustSavedEncrypted = justSavedEncryptedArticle;
            justSavedEncryptedArticle = false; // Reset the flag immediately

            if (article.isEncrypted) {
                displayEncryptedArticlePlaceholder(article); // Display encrypted placeholder
                if (!wasJustSavedEncrypted) { // Only show password prompt if it wasn't just saved encrypted
                    els.passwordPromptModal.dataset.actionType = 'view_decrypt'; // Set action type to view and decrypt
                    showPasswordPrompt(); // Pop up password box
                }
            } else {
                displayArticleDetails(article); // Directly display article details
            }
        };

        /**
         * 更新选中文章的 ID 列表。
         * @param {number} id - 文章 ID。
         */
        const updateSelectedArticles = (id, isChecked) => {
            selectedArticleIds = isChecked ? [...new Set([...selectedArticleIds, id])] : selectedArticleIds.filter(item => item !== id);
            if (els.selectAllCheckbox) { // 更新全选复选框的状态
                const allCheckboxes = QA('.article-checkbox');
                // 确保所有复选框都已选中，才将全选框设为选中
                els.selectAllCheckbox.checked = Array.from(allCheckboxes).every(cb => cb.checked);
            }
            updateBatchActionButtonsState(); // 更新批量操作按钮状态
        };

        /** 切换全选/全不选。 */
        const toggleSelectAll = () => {
            if (!els.selectAllCheckbox) return;
            const isChecked = els.selectAllCheckbox.checked;
            const checkboxes = QA('.article-checkbox');

            // 清除当前页的文章 ID，避免重复添加
            // 修复：从 dataset.id 获取文章ID
            const currentArticleIdsOnPage = Array.from(checkboxes).map(cb => parseInt(cb.dataset.id));
            selectedArticleIds = selectedArticleIds.filter(id => !currentArticleIdsOnPage.includes(id));

            checkboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
                if (isChecked) selectedArticleIds.push(parseInt(checkbox.dataset.id)); // 修复：从 dataset.id 获取文章ID
            });
            updateBatchActionButtonsState();
        };

        /** 更新批量操作按钮的禁用状态。 */
        const updateBatchActionButtonsState = () => {
            const hasSelection = selectedArticleIds.length > 0; // 是否有文章被选中
            const hasTrashedArticles = Storage.getTrashedArticles().length > 0; // 回收站是否有文章

            // 批量操作切换按钮现在始终可见，并控制实际批量操作区域的显示/隐藏
            if (els.toggleBatchActionsBtn) els.toggleBatchActionsBtn.style.display = 'block';

            if (currentView !== '回收站') { // MODIFIED: 'trash' to '回收站' // 非回收站视图
                // 隐藏回收站特有的通知和按钮
                if (els.trashNotification) els.trashNotification.style.display = 'none';
                if (els.batchRestoreBtn) els.batchRestoreBtn.style.display = 'none';
                if (els.emptyTrashBtn) els.emptyTrashBtn.style.display = 'none';

                // 批量操作区域的显示/隐藏由 isBatchActionsVisible 标志控制，此处不再强制设置 display
                // if (els.actualBatchActions) els.actualBatchActions.style.display = 'flex';

                // 恢复常规批量操作按钮文本和状态
                if (els.batchDeleteBtn) {
                    els.batchDeleteBtn.textContent = '删除';
                    els.batchDeleteBtn.disabled = !hasSelection;
                }
                if (els.recategorizeSelect) {
                    els.recategorizeSelect.style.display = 'block'; // Ensure select is visible
                    els.recategorizeSelect.disabled = !hasSelection;
                }
                if (els.selectAllCheckboxContainer) els.selectAllCheckboxContainer.style.display = 'flex';


            } else { // 回收站视图
                // 显示回收站特有的通知
                if (els.trashNotification) els.trashNotification.style.display = 'block';
                // 批量操作切换按钮现在始终可见，此处不再隐藏
                // if (els.toggleBatchActionsBtn) els.toggleBatchActionsBtn.style.display = 'none';

                // 批量操作区域的显示/隐藏由 isBatchActionsVisible 标志控制，此处不再强制设置 display
                // if (els.actualBatchActions) els.actualBatchActions.style.display = 'flex';

                // 隐藏“全部恢复”按钮（因为现在是“恢复选中”）
                if (els.batchRestoreBtn) els.batchRestoreBtn.style.display = 'none';

                // 显示“清空回收站”按钮，并根据是否有文章禁用
                if (els.emptyTrashBtn) {
                    els.emptyTrashBtn.style.display = 'block';
                    els.emptyTrashBtn.disabled = !hasTrashedArticles;
                }

                // 更新批量删除按钮为“永久删除选中”
                if (els.batchDeleteBtn) {
                    els.batchDeleteBtn.textContent = '永久删除选中';
                    els.batchDeleteBtn.disabled = !hasSelection;
                }
                // 重分类选择框用于选择恢复到的分类
                if (els.recategorizeSelect) {
                    els.recategorizeSelect.style.display = 'block';
                    els.recategorizeSelect.disabled = !hasSelection;
                }
                if (els.selectAllCheckboxContainer) els.selectAllCheckboxContainer.style.display = 'flex';
            }
        };

        /**
         * 渲染分页控件。
         * @param {number} totalPages - 总页数。
         */
        const renderPaginationControls = totalPages => {
            els.paginationContainer.innerHTML = '';
            if (totalPages <= 1) {
                els.paginationContainer.style.display = 'none'; // 只有一页或没有文章时隐藏分页
                return;
            }
            els.paginationContainer.style.display = 'flex';

            /**
             * 创建分页按钮。
             * @param {string|number} text - 按钮文本。
             * @param {number} page - 对应的页码。
             * @param {boolean} isDisabled - 是否禁用。
             * @param {Function} onClick - 点击事件处理函数。
             * @returns {HTMLButtonElement} 创建的按钮。
             */
            const createPageBtn = (text, page, isDisabled, onClick) => {
                const btn = document.createElement('button');
                btn.textContent = text;
                btn.className = `btn pagination-btn ${page === currentPage ? 'active' : ''}`; // 激活状态
                btn.disabled = isDisabled;
                btn.onclick = onClick;
                return btn;
            };

            // 上一页按钮
            els.paginationContainer.appendChild(createPageBtn('上一页', currentPage - 1, currentPage === 1, () => {
                if (currentPage > 1) {
                    currentPage--;
                    loadArticles();
                }
            }));

            // 页码按钮
            for (let i = 1; i <= totalPages; i++) {
                els.paginationContainer.appendChild(createPageBtn(i, i, false, () => {
                    currentPage = i;
                    loadArticles();
                }));
            }

            // 下一页按钮
            els.paginationContainer.appendChild(createPageBtn('下一页', currentPage + 1, currentPage === totalPages, () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    loadArticles();
                }
            }));
        };

        /** 加载文章并显示。 */
        const loadArticles = () => {
            els.sidebar.style.display = 'block'; // Show sidebar
            els.listModeControls.style.display = 'block'; // Show list mode controls
            els.detailModeControls.style.display = 'none'; // Hide detail mode controls
            els.detailModeControls.innerHTML = '';
            Q('.content-header').classList.remove('has-bottom-border'); // Remove header border
            els.editActionsFixedSidebar.style.display = 'none'; // Hide fixed sidebar when loading articles

            // Ensure view mode toggle button and pagination are visible when returning to list/card view
            els.toggleViewModeBtn.style.display = 'block';
            els.paginationContainer.style.display = 'block';

            selectedArticleIds = []; // 清空选中文章列表
            if (els.selectAllCheckbox) els.selectAllCheckbox.checked = false; // 取消全选

            // 重置批量操作区域的可见性，使其默认隐藏
            isBatchActionsVisible = false;
            if (els.actualBatchActions) els.actualBatchActions.style.display = 'none';

            // 确保批量操作按钮的文本在切换视图时正确重置
            if (els.batchDeleteBtn) els.batchDeleteBtn.textContent = '删除';
            if (els.batchRecategorizeBtn) els.batchRecategorizeBtn.textContent = '重分类';

            updateBatchActionButtonsState(); // 更新批量操作按钮状态

            // 如果正在阅读文章详情，直接显示详情并返回
            if (isViewingArticle && currentArticleId) {
                viewArticle(currentArticleId);
                return;
            }

            let allArticlesData = currentView === '回收站' ? Storage.getTrashedArticles() : Storage.getArticles(); //  'trash' to '回收站' // 根据当前视图获取文章

            // 新增: 排序文章：置顶文章在前，然后按创建日期降序排列
            allArticlesData.sort((a, b) => {
                // 置顶文章优先
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;

                // 如果置顶状态相同，则按创建日期（最新在前）排序
                const aCreatedAt = a.createdAt || 0;
                const bCreatedAt = b.createdAt || 0;
                return bCreatedAt - aCreatedAt;
            });

            // els.trashNotification.style.display = currentView === 'trash' ? 'block' : 'none'; // 此行现在由 updateBatchActionButtonsState 处理
            // 批量操作切换按钮现在始终可见，此处不再根据视图隐藏
            // els.toggleBatchActionsBtn.style.display = currentView === 'trash' ? 'none' : 'block';

            // 将 'all' 替换为 '全部作品'
            if (currentView !== '全部作品' && currentView !== '回收站') { // MODIFIED: 'trash' to '回收站' // 如果是特定分类视图，则过滤文章
                allArticlesData = allArticlesData.filter(article => article.category === currentView);
            }

            const query = els.searchInput.value.toLowerCase().trim(); // 获取搜索关键词
            // 过滤文章：标题、分类、描述、内容、文献信息
            const filteredArticles = query === '' ? allArticlesData : allArticlesData.filter(article => {
                const searchFields = [article.title, article.category];
                if (!article.isEncrypted) { // 未加密文章才搜索内容和描述
                    searchFields.push(article.description, article.content);
                    if (article.category === '文献材料') { // 文献材料搜索特定字段
                        searchFields.push(article.journal, String(article.year), String(article.impactFactor), article.citation);
                    }
                }
                return searchFields.some(field => field && String(field).toLowerCase().includes(query));
            });

            const articlesPerPage = currentViewMode === 'card' ? ARTICLES_PER_PAGE_CARD : ARTICLES_PER_PAGE_LIST; // 根据视图模式选择每页文章数量

            const totalArticles = filteredArticles.length;
            const totalPages = Math.ceil(totalArticles / articlesPerPage); // 计算总页数

            if (currentPage > totalPages && totalPages > 0) currentPage = totalPages; // 避免页码超出范围
            else if (totalPages === 0) currentPage = 1; // 如果没有文章，页码设为1

            const startIndex = (currentPage - 1) * articlesPerPage;
            const articlesForPage = filteredArticles.slice(startIndex, startIndex + articlesPerPage); // 获取当前页的文章

            generateArticleCards(articlesForPage); // 生成文章卡片
            renderPaginationControls(totalPages); // 渲染分页控件
            updateRecategorizeSelect(); // 重新加载文章时更新重分类下拉框
        };

        /**
         * 将文章移动到回收站。
         * @param {number} id - 文章 ID。
         */
        const moveToTrash = id => {
            console.log(`[moveToTrash] Attempting to move article with ID: ${id}`);
            let articles = Storage.getArticles();
            let trashedArticles = Storage.getTrashedArticles();
            console.log(`[moveToTrash] Articles before:`, articles.map(a => a.id));
            console.log(`[moveToTrash] Trashed Articles before:`, trashedArticles.map(a => a.id));

            const articleToMove = articles.find(a => a.id === parseInt(id));

            if (articleToMove) {
                // 创建新的文章数组，不包含被移动的文章
                const updatedArticles = articles.filter(a => a.id !== parseInt(id));
                Storage.saveArticles(updatedArticles);
                console.log(`[moveToTrash] Articles after removal:`, updatedArticles.map(a => a.id));

                // 将文章添加到回收站
                articleToMove.trashDate = Date.now();
                const newTrashedArticles = [...trashedArticles, articleToMove]; // Create a new array reference
                Storage.saveTrashedArticles(newTrashedArticles);
                console.log(`[moveToTrash] Trashed Articles after adding:`, newTrashedArticles.map(a => a.id));

                showNotification('文章已移至回收站', 'success');
                els.searchInput.value = '';
                loadArticles();
                // 同时更新侧边栏的激活分类样式
                QA('.categories li a').forEach(link => {
                    link.classList.toggle('active', link.dataset.category === currentView);
                });
            } else {
                showNotification('未找到该文章进行删除操作', 'error');
                console.warn(`[moveToTrash] Article with ID ${id} not found in current articles.`);
            }
        };

        /** 批量删除选中的文章 (根据当前视图执行移至回收站或永久删除)。 */
        const handleBatchDelete = () => {
            if (selectedArticleIds.length === 0) {
                showNotification('请选择要操作的文章', 'error');
                return;
            }

            console.log(`[handleBatchDelete] Selected Article IDs:`, selectedArticleIds);
            console.log(`[handleBatchDelete] Current View:`, currentView);

            if (currentView === '回收站') { // MODIFIED: 'trash' to '回收站' // 如果在回收站视图，执行永久删除
                let trashedArticles = Storage.getTrashedArticles();
                console.log(`[handleBatchDelete] Trashed Articles before permanent delete:`, trashedArticles.map(a => a.id));
                const initialCount = trashedArticles.length;
                const articlesToPermanentlyDelete = trashedArticles.filter(a => selectedArticleIds.includes(a.id));
                const remainingTrashedArticles = trashedArticles.filter(a => !selectedArticleIds.includes(a.id));
                Storage.saveTrashedArticles(remainingTrashedArticles);
                const deletedCount = articlesToPermanentlyDelete.length; // Count actually deleted
                console.log(`[handleBatchDelete] Trashed Articles after permanent delete:`, remainingTrashedArticles.map(a => a.id));
                showNotification(`已永久删除 ${deletedCount} 篇文章`, 'success');
            } else { // 否则，移至回收站
                let articles = Storage.getArticles();
                let trashedArticles = Storage.getTrashedArticles();
                console.log(`[handleBatchDelete] Articles before batch move to trash:`, articles.map(a => a.id));
                console.log(`[handleBatchDelete] Trashed Articles before batch move to trash:`, trashedArticles.map(a => a.id));

                let count = 0;
                const articlesToKeep = [];
                const articlesToMoveToTrash = [];

                articles.forEach(article => {
                    if (selectedArticleIds.includes(article.id)) {
                        article.trashDate = Date.now();
                        articlesToMoveToTrash.push(article);
                        count++;
                    } else {
                        articlesToKeep.push(article);
                    }
                });

                Storage.saveArticles(articlesToKeep); // Saves articles (without the moved ones)
                Storage.saveTrashedArticles([...trashedArticles, ...articlesToMoveToTrash]); // Saves trashed articles (with the new ones)

                console.log(`[handleBatchDelete] Articles after batch move to trash:`, articlesToKeep.map(a => a.id));
                console.log(`[handleBatchDelete] Trashed Articles after batch move to trash:`, [...trashedArticles, ...articlesToMoveToTrash].map(a => a.id));

                showNotification(`已将 ${count} 篇文章移至回收站`, 'success');
                // 修复：自动切换到回收站视图，并清空搜索框以确保显示所有回收站文章
                currentView = '回收站';
                els.searchInput.value = '';
                // The loadArticles() call below will handle the refresh.
                // QA('.categories li a').forEach(link => { // This is handled by loadArticles -> attachCategoryLinkListeners -> updateRecategorizeSelect
                //     link.classList.toggle('active', link.dataset.category === currentView);
                // });
            }
            selectedArticleIds = [];
            if (els.selectAllCheckbox) els.selectAllCheckbox.checked = false;
            loadArticles(); // This call is essential for refreshing the view.
        };

        /**
         * 从回收站恢复文章。
         * @param {number} id - 文章 ID。
         */
        const restoreFromTrash = id => {
            let trashedArticles = Storage.getTrashedArticles();
            const index = trashedArticles.findIndex(a => a.id === parseInt(id));
            if (index !== -1) {
                const [article] = trashedArticles.splice(index, 1); // 从回收站移除
                delete article.trashDate; // 移除回收站日期
                Storage.saveTrashedArticles(trashedArticles);
                Storage.saveArticles([...Storage.getArticles(), article]); // 添加回文章列表
                showNotification('文章已恢复', 'success');
                loadArticles();
            }
        };

        /** 批量恢复选中的文章。 */
        const batchRestoreFromTrash = () => {
            const trashedArticles = Storage.getTrashedArticles();
            if (trashedArticles.length === 0) {
                showNotification('回收站中没有可恢复的文章', 'error');
                return;
            }
            let articles = Storage.getArticles();
            trashedArticles.forEach(article => delete article.trashDate); // 移除所有回收站文章的日期
            Storage.saveArticles([...articles, ...trashedArticles]); // 合并到文章列表
            Storage.saveTrashedArticles([]); // 清空回收站
            showNotification(`已恢复 ${trashedArticles.length} 篇文章`, 'success');
            selectedArticleIds = [];
            if (els.selectAllCheckbox) els.selectAllCheckbox.checked = false;
            loadArticles();
        };

        /**
         * 批量设置文章分类或从回收站恢复。
         * @param {string} category - 目标分类名称。
         */
        const batchSetCategory = category => {
            if (selectedArticleIds.length === 0) {
                showNotification('请选择要重分类的文章', 'error');
                return;
            }
            let articles = Storage.getArticles();
            let count = 0;
            articles.forEach(article => {
                if (selectedArticleIds.includes(article.id)) {
                    article.category = category; // 设置新分类
                    count++;
                    if (category === '文献材料') { // 如果是文献材料，清空描述
                        article.description = article.isEncrypted ? encryptData('', '000000') : '';
                    } else { // 如果不是文献材料，清空文献相关字段
                        article.journal = article.year = article.impactFactor = article.citation = '';
                    }
                }
            });
            Storage.saveArticles(articles);
            showNotification(`已为 ${count} 篇文章设置分类为: ${category}`, 'success');
            selectedArticleIds = [];
            if (els.selectAllCheckbox) els.selectAllCheckbox.checked = false;
            loadArticles();
        };

        /** 处理批量重分类或批量恢复操作 */
        const handleBatchRecategorizeOrRestore = () => {
            if (selectedArticleIds.length === 0) {
                showNotification('请选择要操作的文章', 'error');
                return;
            }
            const selectedValue = els.recategorizeSelect.value;
            if (!selectedValue) {
                showNotification('请选择一个分类', 'error');
                return;
            }

            if (currentView === '回收站') { // MODIFIED: 'trash' to '回收站' // 如果在回收站视图，执行恢复操作
                if (selectedValue === 'create_new_category') {
                    showNotification('在回收站模式下不能创建新分类进行恢复，请选择现有分类。', 'error');
                    els.recategorizeSelect.value = ''; // Reset dropdown
                    return;
                }
                let trashedArticles = Storage.getTrashedArticles();
                let articles = Storage.getArticles();
                let count = 0;

                const restoredArticles = [];
                const remainingTrashedArticles = [];

                trashedArticles.forEach(article => {
                    if (selectedArticleIds.includes(article.id)) {
                        delete article.trashDate;
                        article.category = selectedValue; // 恢复到选定的分类
                        restoredArticles.push(article);
                        count++;
                    } else {
                        remainingTrashedArticles.push(article);
                    }
                });
                Storage.saveTrashedArticles(remainingTrashedArticles);
                Storage.saveArticles([...articles, ...restoredArticles]);
                showNotification(`已将 ${count} 篇文章恢复到 "${selectedValue}"`, 'success');
            } else { // 否则，执行重分类操作
                if (selectedValue === 'create_new_category') { // 如果选择了“创建新分类”
                    showGenericModal('创建新分类', '', true, '请输入新分类名称', (newCatName) => {
                        if (addNewCategory(newCatName)) {
                            batchSetCategory(newCatName); // 创建成功后，应用于选中的文章
                        }
                    }, () => showNotification('已取消创建新分类', 'info'));
                    els.recategorizeSelect.value = ''; // 重置下拉框
                    return;
                }
                batchSetCategory(selectedValue);
            }
            selectedArticleIds = [];
            if (els.selectAllCheckbox) els.selectAllCheckbox.checked = false;
            loadArticles();
        };

        /**
         * 永久删除文章 (从回收站)。
         * @param {number} id - 文章 ID。
         */
        const permanentDelete = id => {
            Storage.saveTrashedArticles(Storage.getTrashedArticles().filter(a => a.id !== parseInt(id))); // 过滤掉要删除的文章
            showNotification('文章已永久删除', 'success');
            loadArticles();
        };

        /** 清空回收站。 */
        const emptyTrash = () => {
            const trashedArticles = Storage.getTrashedArticles();
            if (trashedArticles.length === 0) {
                showNotification('回收站已经是空的', 'error');
                return;
            }
            Storage.saveTrashedArticles([]); // 清空回收站
            showNotification(`已永久删除 ${trashedArticles.length} 篇文章`, 'success');
            loadArticles();
        };

        /** 执行文章搜索。 */
        const searchArticles = () => {
            currentPage = 1; // 搜索时重置页码
            loadArticles();
        };

        /** 创建新文章 (跳转到文章编辑表单)。 */
        const createNewArticle = () => renderArticleForm();

        // --- 富文本编辑器功能 ---

        /**
         * 应用格式化命令到编辑器。
         * @param {HTMLElement} editorDiv - 编辑器内容区域。
         * @param {string} command - 格式化命令 (如 'bold', 'italic', 'blockquote', 'bgcolor-red' 等)。
         */
        const applyFormatting = (editorDiv, command) => {
            editorDiv.focus(); // 聚焦编辑器
            try {
                if (command === 'blockquote') { // 特殊处理引用块
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        let currentBlock = range.startContainer;
                        let isInsideBlockquote = false;
                        // 检查当前选区是否在 blockquote 内部
                        while (currentBlock && currentBlock !== editorDiv) {
                            if (currentBlock.nodeType === Node.ELEMENT_NODE && currentBlock.tagName.toLowerCase() === 'blockquote') {
                                isInsideBlockquote = true;
                                break;
                            }
                            // 如果遇到其他块级元素，停止向上查找
                            if (currentBlock.tagName && currentBlock.tagName.match(/^(P|DIV|H[1-6]|LI)$/i)) break;
                            currentBlock = currentBlock.parentNode;
                        }
                        // 如果在 blockquote 内部，则取消 blockquote 格式，否则应用 blockquote
                        document.execCommand('formatBlock', false, isInsideBlockquote ? 'p' : 'blockquote');
                    }
                } else if (command.startsWith('bgcolor-')) { // 处理背景色
                    const colorMap = {
                        'bgcolor-red': 'rgba(255, 0, 0, 0.3)',
                        'bgcolor-yellow': 'rgba(255, 255, 0, 0.3)',
                        'bgcolor-green': 'rgba(92, 255, 222, 0.3)',
                        'bgcolor-blue': 'rgba(77, 145, 255, 0.3)',
                        'bgcolor-grey': 'rgba(128, 128, 128, 0.3)'
                    };
                    applyOrClearBackgroundColor(editorDiv, colorMap[command]);
                } else if (command === 'clear-bgcolor') { // 清除背景色
                    applyOrClearBackgroundColor(editorDiv, '');
            } else if (command.startsWith('fontname-')) { // 处理字体
                const fontName = command.replace('fontname-', '');
                // 直接使用 execCommand('fontName')，在 styleWithCSS 模式下会插入带 font-family 的 span
                document.execCommand('fontName', false, fontName); 
            }

                else {
                    document.execCommand(command, false, null); // 执行通用格式化命令
                }
            } catch (e) {
                console.error("Error applying formatting for command:", command, e);
            }
        };

        /**
         * 应用或清除背景颜色。
         * @param {HTMLElement} editorDiv - 编辑器内容区域。
         * @param {string} color - 要应用的颜色值 (如 'rgba(255,0,0,0.3)') 或空字符串表示清除。
         */
        const applyOrClearBackgroundColor = (editorDiv, color) => {
            editorDiv.focus(); // 聚焦编辑器
            try {
                if (color === '') { // 清除背景色模式
                    // 使用 'transparent' 来清除背景色，execCommand 会处理替换逻辑
                    document.execCommand('backColor', false, 'transparent');
                } else { // 应用背景色模式
                    document.execCommand('backColor', false, color);
                }
            } catch (e) {
                console.error("Error applying background color command:", e);
            }
        };

        /**
         * 创建编辑器工具栏按钮。
         * @param {string} label - 按钮文本。
         * @param {string} command - 格式化命令。
         * @param {HTMLElement} editorDiv - 编辑器内容区域。
         * @param {string} tooltip - 按钮的工具提示文本。
         * @returns {HTMLButtonElement} 创建的按钮。
         */
        const createToolbarButton = (label, command, editorDiv, tooltip) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = label;
            button.dataset.command = command;
            button.title = tooltip; // 添加 title 属性作为 tooltip

            // 根据命令添加样式，使其符号本身具有对应效果
            if (command === 'bold') {
                button.style.fontWeight = 'bold';
            } else if (command === 'underline') {
                button.style.textDecoration = 'underline';
            } else if (command === 'italic') {
                button.style.fontStyle = 'italic';
            } else if (command === 'strikethrough') {
                button.style.textDecoration = 'line-through';
            }

            // Only general formatting commands need active state updates
            if (!command.startsWith('bgcolor-') && !command.startsWith('fontname-') && !command.startsWith('justify') && command !== 'clear-bgcolor' && command !== 'clear-fontname') {
                button.updateActiveState = () => {
                    if (command === 'blockquote') { // 引用块的激活状态判断
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            let node = selection.getRangeAt(0).commonAncestorContainer;
                            while (node && node !== editorDiv) {
                                if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === 'blockquote') {
                                    button.classList.add('active');
                                    return;
                                }
                                if (node.tagName && node.tagName.match(/^(P|DIV|H[1-6]|LI)$/i)) break;
                                node = node.parentNode;
                            }
                        }
                        button.classList.remove('active');
                    } else { // 其他命令直接使用 queryCommandState
                        button.classList.toggle('active', document.queryCommandState(command));
                    }
                };
                editorToolbarButtons.push(button); // 将按钮添加到全局数组中
            } else {
                button.updateActiveState = () => {}; // These buttons don't need active state updates
            }

            button.onclick = () => {
                applyFormatting(editorDiv, command); // 应用格式化
                // Update all toolbar buttons except for color/font/alignment pickers
                if (!command.startsWith('bgcolor-') && !command.startsWith('fontname-') && !command.startsWith('justify') && command !== 'clear-bgcolor' && command !== 'clear-fontname') {
                    updateAllToolbarButtonStates();
                }
                editorDiv.focus(); // 重新聚焦编辑器
            };
            return button;
        };

        /** Update all editor toolbar button states. */
        const updateAllToolbarButtonStates = () => {
            editorToolbarButtons.forEach(button => {
                if (typeof button.updateActiveState === 'function') {
                    button.updateActiveState();
                }
            });
        };

        // --- 文章表单 (创建/编辑) ---

        /**
         * 渲染文章创建/编辑表单。
         * @param {Object} [article=null] - 要编辑的文章对象，如果为 null 则表示创建新文章。
         */
        const renderArticleForm = (article = null) => {
            els.sidebar.style.display = 'none'; // Hide sidebar
            isViewingArticle = false; // Not in view mode
            currentArticleId = article ? article.id : null; // Set current article ID
            selectedArticleIds = []; // Clear selected list
            if (els.selectAllCheckbox) els.selectAllCheckbox.checked = false;

            els.listModeControls.style.display = 'none'; // Hide list mode controls
            els.detailModeControls.style.display = 'none'; // Hide detail mode controls
            els.detailModeControls.innerHTML = ''; // Clear detail mode controls area
            Q('.content-header').classList.remove('has-bottom-border'); // Remove header border

            // Hide view mode toggle button and pagination in article edit/create mode
            els.toggleViewModeBtn.style.display = 'none';
            els.paginationContainer.style.display = 'none';

            els.editActionsFixedSidebar.innerHTML = '';
            els.editActionsFixedSidebar.style.display = 'flex'; // Show the fixed sidebar

            els.articlesContainer.innerHTML = ''; // 清空文章容器
            const editForm = document.createElement('div');
            editForm.className = 'article-detail-container'; // Use article detail container style

            const formHeaderRow = document.createElement('div');
            formHeaderRow.className = 'form-header-row';

            /**
             * 创建输入字段 (带标签)。
             * @param {string} label - 标签文本。
             * @param {string} type - 输入框类型。
             * @param {string} value - 输入框初始值。
             * @param {string} placeholder - 占位符文本。
             * @param {string} [id=null] - 输入框 ID。
             * @returns {{group: HTMLDivElement, input: HTMLInputElement}} 包含标签和输入框的 div 元素及输入框本身。
             */
            const createInputField = (label, type, value, placeholder, id = null) => {
                const group = document.createElement('div');
                group.className = 'form-field-group'; // Add generic class for styling
                const lbl = document.createElement('label');
                lbl.textContent = label;
                const input = document.createElement('input');
                input.type = type;
                input.value = value;
                input.placeholder = placeholder;
                input.style.cssText = 'width: 100%; padding: 10px; background-color: var(--frosted-card-bg); color: var(--text-color); border: 1px solid var(--frosted-border); border-radius: var(--border-radius);';
                if (id) input.id = id;
                group.append(lbl, input);
                return {
                    group,
                    input
                };
            };

            // 标题输入框
            const {
                group: titleGroup,
                input: titleInput
            } = createInputField('标题', 'text', article ? article.title : '', '请输入文章标题');
            formHeaderRow.appendChild(titleGroup);

            // 分类选择下拉框
            const categoryGroup = document.createElement('div');
            categoryGroup.className = 'category-group form-field-group'; // Added form-field-group
            const categoryLabel = document.createElement('label');
            categoryLabel.textContent = '分类';
            const categorySelect = document.createElement('select');
            categorySelect.style.cssText = 'width: 100%; padding: 10px; background-color: var(--frosted-card-bg); color: var(--text-color); border: 1px solid var(--frosted-border); border-radius: var(--border-radius);';

            allCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                if (article && cat === article.category) option.selected = true;
                categorySelect.appendChild(option);
            });
            categoryGroup.append(categoryLabel, categorySelect);
            formHeaderRow.appendChild(categoryGroup);

            // 创建日期输入框和显示选项
            const createdAtGroup = document.createElement('div');
            createdAtGroup.className = 'form-field-group';
            const createdAtLabel = document.createElement('label');
            createdAtLabel.textContent = '创建日期';

            // NEW: Container for the date input and the "Show Date" checkbox
            const dateAndCheckboxRow = document.createElement('div');
            dateAndCheckboxRow.style.cssText = 'display: flex; align-items: center; gap: 10px; flex-wrap: wrap;';

            const createdAtInput = document.createElement('input');
            createdAtInput.type = 'date';
            createdAtInput.value = article ? formatTimestampForInput(article.createdAt) : formatTimestampForInput(Date.now());
            createdAtInput.placeholder = '';
            createdAtInput.id = 'createdAtInput';
            createdAtInput.style.cssText = 'width: 200px; padding: 10px; background-color: var(--frosted-card-bg); color: var(--text-color); border: 1px solid var(--frosted-border); border-radius: var(--border-radius);';

            const showCreatedAtOptionContainer = document.createElement('div');
            showCreatedAtOptionContainer.style.cssText = 'display: flex; align-items: center; gap: 5px;'; // This container holds the checkbox and its label

            const showCreatedAtCheckbox = document.createElement('input');
            showCreatedAtCheckbox.type = 'checkbox';
            showCreatedAtCheckbox.id = 'showCreatedAtCheckbox';
            // Initialize checkbox state based on article data or default to true
            showCreatedAtCheckbox.checked = article ? (article.showCreatedAt !== false) : true; // Default to true if not specified

            const showCreatedAtLabel = document.createElement('label');
            showCreatedAtLabel.htmlFor = 'showCreatedAtCheckbox';
            showCreatedAtLabel.textContent = '显示日期';
            showCreatedAtLabel.style.cssText = 'color: var(--light-text); font-size: 14px;';

            showCreatedAtOptionContainer.append(showCreatedAtCheckbox, showCreatedAtLabel);
            dateAndCheckboxRow.append(createdAtInput, showCreatedAtOptionContainer); // Append both to the new row container

            createdAtGroup.append(createdAtLabel, dateAndCheckboxRow); // Append label and the new row container to createdAtGroup
            formHeaderRow.appendChild(createdAtGroup);

            // Event listener for showCreatedAtCheckbox
            showCreatedAtCheckbox.onchange = () => {
                const isChecked = showCreatedAtCheckbox.checked;
                // ONLY hide/show the date input field, not the checkbox itself
                createdAtInput.style.display = isChecked ? 'block' : 'none';
            };

            // Initial display state for the date input field
            const initialShowCreatedAt = article ? (article.showCreatedAt !== false) : true;
            createdAtInput.style.display = initialShowCreatedAt ? 'block' : 'none'; // Set initial display for date input

            editForm.appendChild(formHeaderRow);

            // 简介输入框
            const descriptionGroup = document.createElement('div');
            descriptionGroup.id = 'descriptionGroup';
            const descLabel = document.createElement('label');
            descLabel.textContent = '简介';
            descLabel.style.cssText = 'display: block; margin-bottom: 5px;';
            const descInput = document.createElement('input');
            descInput.type = 'text';
            descInput.id = 'descInput';
            descInput.value = article ? article.description : '';
            descInput.placeholder = '请输入文章简介';
            descInput.style.cssText = 'width: 100%; padding: 10px; margin-bottom: 15px; background-color: var(--frosted-card-bg); color: var(--text-color); border: 1px solid var(--frosted-border); border-radius: var(--border-radius);';
            descriptionGroup.append(descLabel, descInput);
            editForm.appendChild(descriptionGroup);

            // 文献相关字段容器 (默认隐藏)
            const literatureFieldsContainer = document.createElement('div');
            literatureFieldsContainer.id = 'literatureFieldsContainer';
            literatureFieldsContainer.className = 'literature-input-group';
            literatureFieldsContainer.style.display = 'none';

            // 文献相关输入框
            const {
                input: journalInput
            } = createInputField('期刊', 'text', article ? article.journal : '', '请输入期刊名称', 'journalInput');
            const {
                input: yearInput
            } = createInputField('年份', 'text', article ? article.year : '', '请输入年份', 'yearInput');
            const {
                input: impactFactorInput
            } = createInputField('影响因子', 'text', article ? article.impactFactor : '', '请输入影响因子', 'impactFactorInput');
            const {
                input: citationInput
            } = createInputField('引用', 'text', article ? article.citation : '', '请粘贴引用格式', 'citationInput');

            literatureFieldsContainer.append(journalInput.closest('div'), yearInput.closest('div'), impactFactorInput.closest('div'), citationInput.closest('div'));
            editForm.appendChild(literatureFieldsContainer);

            // 加密选项和工具栏行
            const encryptionToolbarRow = document.createElement('div');
            encryptionToolbarRow.className = 'encryption-toolbar-row';

            const encryptionOptionsDiv = document.createElement('div');
            encryptionOptionsDiv.className = 'encryption-options';

            // 启用加密复选框
            const enableEncryptionContainer = document.createElement('div');
            enableEncryptionContainer.style.cssText = 'display: flex; align-items: center; gap: 10px; margin-bottom: 10px;';
            const enableEncryptionCheckbox = document.createElement('input');
            enableEncryptionCheckbox.type = 'checkbox';
            enableEncryptionCheckbox.id = 'enableEncryptionCheckbox';
            enableEncryptionCheckbox.checked = article ? article.isEncrypted : false;
            const enableEncryptionLabel = document.createElement('label');
            enableEncryptionLabel.htmlFor = 'enableEncryptionCheckbox';
            enableEncryptionLabel.textContent = '启用加密';
            enableEncryptionLabel.style.fontWeight = 'bold';

            // 显示文章字数复选框
            const showWordCountCheckbox = document.createElement('input');
            showWordCountCheckbox.type = 'checkbox';
            showWordCountCheckbox.id = 'showWordCountCheckbox';
            showWordCountCheckbox.checked = article ? !!article.showWordCount : false; // 默认不勾选
            const showWordCountLabel = document.createElement('label');
            showWordCountLabel.htmlFor = 'showWordCountCheckbox';
            showWordCountLabel.textContent = '显示文章字数';
            showWordCountLabel.style.cssText = 'font-weight: normal; color: var(--light-text); font-size: 14px;';

            // 内容框自动增大高度复选框
            const autoGrowContentCheckbox = document.createElement('input');
            autoGrowContentCheckbox.type = 'checkbox';
            autoGrowContentCheckbox.id = 'autoGrowContentCheckbox';
            autoGrowContentCheckbox.checked = article ? !!article.autoGrowContent : false; // 默认不勾选
            const autoGrowContentLabel = document.createElement('label');
            autoGrowContentLabel.htmlFor = 'autoGrowContentCheckbox';
            autoGrowContentLabel.textContent = '内容框自动增大';
            autoGrowContentLabel.style.cssText = 'font-weight: normal; color: var(--light-text); font-size: 14px;';

            enableEncryptionContainer.append(
                enableEncryptionCheckbox,
                enableEncryptionLabel,
                showWordCountCheckbox,
                showWordCountLabel, 
                // Append the new checkbox and label
                autoGrowContentCheckbox,
                autoGrowContentLabel
            );
            encryptionOptionsDiv.appendChild(enableEncryptionContainer);

            // 加密密码输入区域 (默认隐藏)
            const encryptionPasswordField = document.createElement('div');
            encryptionPasswordField.id = 'encryptionPasswordField';
            encryptionPasswordField.style.display = enableEncryptionCheckbox.checked ? 'block' : 'none';

            const {
                input: encryptionPasswordInput
            } = createInputField('加密密码 (6位数字)', 'password', '', '请输入6位数字密码');
            encryptionPasswordInput.maxLength = 6;
            encryptionPasswordInput.pattern = '\\d{6}';
            encryptionPasswordInput.inputmode = 'numeric';
            encryptionPasswordInput.style.marginBottom = '10px';

            const {
                input: confirmEncryptionPasswordInput
            } = createInputField('确认密码', 'password', '', '请再次输入密码');

            encryptionPasswordField.append(encryptionPasswordInput.closest('div'), confirmEncryptionPasswordInput.closest('div'));
            encryptionOptionsDiv.appendChild(encryptionPasswordField);
            encryptionToolbarRow.appendChild(encryptionOptionsDiv);

            // 启用加密复选框的事件监听器
            enableEncryptionCheckbox.onchange = () => {
                encryptionPasswordField.style.display = enableEncryptionCheckbox.checked ? 'block' : 'none';
                if (!enableEncryptionCheckbox.checked) { // 如果取消加密，清空密码
                    encryptionPasswordInput.value = '';
                    confirmEncryptionPasswordInput.value = '';
                }
            };

            // 内容编辑器标签
            const contentLabel = document.createElement('label');
            contentLabel.textContent = '内容';
            contentLabel.style.cssText = 'display: block; margin-bottom: 5px;';
            editForm.appendChild(contentLabel);

            // 内容编辑器区域
            const contentEditorDiv = document.createElement('div');
            contentEditorDiv.contentEditable = true; // 可编辑
            // 在注释行（blockquote）行首按删除键取消注释格式
            contentEditorDiv.addEventListener('keydown', e => {
                if (e.key === 'Backspace') {
                    const selection = window.getSelection();
                    // 确保是折叠光标（不是选中区域）
                    if (selection.rangeCount > 0 && selection.isCollapsed) {
                        const range = selection.getRangeAt(0);

                        // 向上遍历DOM树，找到光标所在的最近的块级元素
                        let currentBlock = range.startContainer;
                        while (currentBlock && currentBlock !== contentEditorDiv && !['P', 'DIV', 'BLOCKQUOTE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI'].includes(currentBlock.tagName?.toUpperCase())) {
                            currentBlock = currentBlock.parentNode;
                        }

                        // 如果找到的块级元素是 BLOCKQUOTE
                        if (currentBlock && currentBlock.tagName?.toUpperCase() === 'BLOCKQUOTE') {
                            // 检查光标是否在 BLOCKQUOTE 内容的最开始（即 BLOCKQUOTE内部没有内容在光标之前）
                            const tempRange = document.createRange();
                            tempRange.selectNodeContents(currentBlock);
                            tempRange.setEnd(range.startContainer, range.startOffset);
                            const contentBeforeCursor = tempRange.toString().trim();

                            if (contentBeforeCursor === '') {
                                e.preventDefault(); // 阻止默认的Backspace行为（删除字符）
                                document.execCommand('formatBlock', false, 'p'); // 将blockquote转换为p标签
                            }
                        }
                    }
                }
            });
            contentEditorDiv.className = 'content-editor-div';
            contentEditorDiv.setAttribute('data-placeholder', '请输入文章内容');
            contentEditorDiv.innerHTML = article ? article.content : '';
            editForm.appendChild(contentEditorDiv);

            // NEW: Auto-grow content checkbox event listener
            autoGrowContentCheckbox.onchange = () => {
                if (autoGrowContentCheckbox.checked) {
                    contentEditorDiv.classList.add('auto-grow');
                } else {
                    contentEditorDiv.classList.remove('auto-grow');
                }
            };

            // NEW: Apply initial auto-grow state when rendering the form
            if (article && article.autoGrowContent) {
                contentEditorDiv.classList.add('auto-grow');
            }

            // 编辑器工具栏包装器
            const contentToolbarWrapper = document.createElement('div');
            contentToolbarWrapper.className = 'editor-toolbar-wrapper';
            const contentToolbar = document.createElement('div');
            contentToolbar.className = 'editor-toolbar';

            editorToolbarButtons = []; // 重置工具栏按钮数组
            contentToolbar.append(
                createToolbarButton('B', 'bold', contentEditorDiv, '加粗'),
                createToolbarButton('U', 'underline', contentEditorDiv, '下划线'),
                createToolbarButton('I', 'italic', contentEditorDiv, '斜体'),
                createToolbarButton('S', 'strikethrough', contentEditorDiv, '删除线'),
                createToolbarButton('注释', 'blockquote', contentEditorDiv, '注释')
            );

            // Alignment picker button and palette wrapper
            const alignmentPickerWrapper = document.createElement('div');
            alignmentPickerWrapper.className = 'alignment-picker-wrapper';

            const alignmentPickerBtn = document.createElement('button');
            alignmentPickerBtn.type = 'button';
            alignmentPickerBtn.className = 'btn';
            alignmentPickerBtn.textContent = '对齐'; // New button text
            alignmentPickerWrapper.appendChild(alignmentPickerBtn);

            const alignmentPalette = document.createElement('div');
            alignmentPalette.className = 'alignment-palette';
            alignmentPalette.style.display = 'none';

            // Add alignment icon buttons (using text labels for now)
            const alignLeftBtn = document.createElement('button');
            alignLeftBtn.type = 'button';
            alignLeftBtn.className = 'alignment-swatch';
            alignLeftBtn.textContent = '左'; // Text label for left align
            alignLeftBtn.title = '左对齐';
            alignLeftBtn.onclick = () => { applyFormatting(contentEditorDiv, 'justifyleft'); alignmentPalette.style.display = 'none'; };

            const alignCenterBtn = document.createElement('button');
            alignCenterBtn.type = 'button';
            alignCenterBtn.className = 'alignment-swatch';
            alignCenterBtn.textContent = '中'; // Text label for center align
            alignCenterBtn.title = '居中对齐';
            alignCenterBtn.onclick = () => { applyFormatting(contentEditorDiv, 'justifycenter'); alignmentPalette.style.display = 'none'; };

            const alignRightBtn = document.createElement('button');
            alignRightBtn.type = 'button';
            alignRightBtn.className = 'alignment-swatch';
            alignRightBtn.textContent = '右'; // Text label for right align
            alignRightBtn.title = '右对齐';
            alignRightBtn.onclick = () => { applyFormatting(contentEditorDiv, 'justifyright'); alignmentPalette.style.display = 'none'; };

            alignmentPalette.append(alignLeftBtn, alignCenterBtn, alignRightBtn);
            alignmentPickerWrapper.appendChild(alignmentPalette);
            contentToolbar.appendChild(alignmentPickerWrapper);

            // Event listener for the main alignment button
            alignmentPickerBtn.onclick = e => {
                e.stopPropagation();
                alignmentPalette.style.display = alignmentPalette.style.display === 'none' ? 'flex' : 'none';
            };


            // 新增：颜色选择器按钮及其面板的包装器
            const colorPickerWrapper = document.createElement('div');
            colorPickerWrapper.className = 'color-picker-wrapper';

            // 背景色选择按钮
            const bgColorPickerBtn = document.createElement('button');
            bgColorPickerBtn.type = 'button';
            bgColorPickerBtn.className = 'btn';
            bgColorPickerBtn.textContent = '背景色';
            colorPickerWrapper.appendChild(bgColorPickerBtn); // 将按钮添加到新的包装器中

            // 背景色调色板 (默认隐藏)
            const bgColorPalette = document.createElement('div');
            bgColorPalette.className = 'color-palette';
            bgColorPalette.style.display = 'none';

            const colorCommands = {
                'bgcolor-red': 'rgba(255, 0, 0, 0.5)',
                'bgcolor-yellow': 'rgba(255, 255, 0, 0.5)',
                'bgcolor-green': 'rgba(92, 255, 222, 0.5)',
                'bgcolor-blue': 'rgba(77, 145, 255, 0.5)',
                'bgcolor-grey': 'rgba(128, 128, 128, 0.5)'
            };

            // Add color swatches
            for (const command in colorCommands) {
                const swatch = document.createElement('button');
                swatch.type = 'button';
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = colorCommands[command];
                swatch.title = command.replace('bgcolor-', '').toUpperCase();
                swatch.dataset.command = command;
                swatch.onclick = () => {
                    applyFormatting(contentEditorDiv, swatch.dataset.command);
                    bgColorPalette.style.display = 'none'; // Hide palette after selection
                };
                bgColorPalette.appendChild(swatch);
            }

            // Add clear color button
            const clearSwatch = document.createElement('button');
            clearSwatch.type = 'button';
            clearSwatch.className = 'color-swatch clear-color-swatch';
            clearSwatch.textContent = '无';
            clearSwatch.title = '清除背景色';
            clearSwatch.dataset.command = 'clear-bgcolor';
            clearSwatch.onclick = () => {
                applyFormatting(contentEditorDiv, clearSwatch.dataset.command);
                bgColorPalette.style.display = 'none';
            };
            bgColorPalette.appendChild(clearSwatch);
            colorPickerWrapper.appendChild(bgColorPalette); // 将颜色面板添加到新的包装器中
            contentToolbar.appendChild(colorPickerWrapper); // 将新的包装器添加到工具栏中

            // Background color picker button click event: toggle palette visibility
            bgColorPickerBtn.onclick = e => {
                e.stopPropagation();
                bgColorPalette.style.display = bgColorPalette.style.display === 'none' ? 'flex' : 'none';
            };
            // Click outside to hide palette
            // This will be handled by the single document.onclick listener at the end of the script

            // Font picker button and palette wrapper
            const fontPickerWrapper = document.createElement('div');
            fontPickerWrapper.className = 'font-picker-wrapper';

            // 字体选项
            const fontPickerBtn = document.createElement('button');
            fontPickerBtn.type = 'button';
            fontPickerBtn.className = 'btn';
            fontPickerBtn.textContent = '字体';
            fontPickerBtn.title = '默认为宋体'; 
            fontPickerWrapper.appendChild(fontPickerBtn);

            // Font palette (initially hidden)
            const fontPalette = document.createElement('div');
            fontPalette.className = 'font-palette';
            fontPalette.style.display = 'none';

            // START OF MODIFICATION
            const fontCommands = {
                '黑体': '黑体',
                '宋体': '宋体',
                '楷体': '楷体',
                '仿宋': '仿宋'
            };
            // END OF MODIFICATION

            // Add font swatches
            for (const fontLabel in fontCommands) {
                const fontName = fontCommands[fontLabel];
                const swatch = document.createElement('button');
                swatch.type = 'button';
                swatch.className = 'font-swatch';
                swatch.textContent = fontLabel;
                swatch.title = fontLabel;
                swatch.dataset.command = `fontname-${fontName}`;
                swatch.dataset.font = fontName; // Add data-font for CSS styling
                swatch.onclick = () => {
                    applyFormatting(contentEditorDiv, swatch.dataset.command);
                    fontPalette.style.display = 'none'; // Hide palette after selection
                };
                fontPalette.appendChild(swatch);
            }

            // Removed: Clear font button as per request
            /*
            const clearFontSwatch = document.createElement('button');
            clearFontSwatch.type = 'button';
            clearFontSwatch.className = 'font-swatch clear-font-swatch';
            clearSwatch.textContent = '清';
            clearSwatch.title = '清除字体';
            clearSwatch.dataset.command = 'clear-fontname';
            clearSwatch.onclick = () => {
                applyFormatting(contentEditorDiv, clearSwatch.dataset.command);
                fontPalette.style.display = 'none';
            };
            fontPalette.appendChild(clearFontSwatch);
            */
            fontPickerWrapper.appendChild(fontPalette);
            contentToolbar.appendChild(fontPickerWrapper);

            // FIX: Add onclick event for the font picker button
            fontPickerBtn.onclick = e => {
                e.stopPropagation();
                fontPalette.style.display = fontPalette.style.display === 'none' ? 'flex' : 'none';
            };


            contentToolbarWrapper.appendChild(contentToolbar);
            encryptionToolbarRow.appendChild(contentToolbarWrapper);
            editForm.appendChild(encryptionToolbarRow);

            // Listen for content changes and selection changes in the editor to update toolbar button states
            contentEditorDiv.addEventListener('input', updateAllToolbarButtonStates);
            contentEditorDiv.addEventListener('mouseup', updateAllToolbarButtonStates);
            contentEditorDiv.addEventListener('keyup', updateAllToolbarButtonStates);
            setTimeout(updateAllToolbarButtonStates, 50); // Delay update to ensure DOM is rendered

            // Bottom save/cancel buttons
            // const buttonContainer = document.createElement('div'); // Removed
            // buttonContainer.style.cssText = 'display: flex; gap: 10px; margin-top: 20px;'; // Removed

            const saveButton = document.createElement('button');
            saveButton.className = 'btn';
            saveButton.textContent = '保存';
            saveButton.onclick = () => {
                const isEncrypted = enableEncryptionCheckbox.checked;
                let encryptionPassword = '';

                if (isEncrypted) { // If encryption is enabled, validate password
                    encryptionPassword = encryptionPasswordInput.value;
                    if (!/^\d{6}$/.test(encryptionPassword) || encryptionPassword !== confirmEncryptionPasswordInput.value) {
                        showNotification('密码必须是6位数字且两次输入一致', 'error');
                        return;
                    }
                }

                const createdAtTimestamp = new Date(createdAtInput.value).getTime();
                const articleData = {
                    id: article ? article.id : Date.now(),
                    title: titleInput.value.trim() || '无标题文章',
                    content: contentEditorDiv.innerHTML.trim() || '无内容',
                    category: categorySelect.value,
                    date: new Date(createdAtTimestamp).toISOString().split('T')[0],
                    createdAt: createdAtTimestamp,
                    showCreatedAt: showCreatedAtCheckbox.checked,
                    isEncrypted: isEncrypted,
                    showWordCount: showWordCountCheckbox.checked,  // 新增字段
                    autoGrowContent: autoGrowContentCheckbox.checked // NEW: Add auto-grow state
                };

                if (articleData.category === '文献材料') { // 特殊处理文献材料分类
                    articleData.journal = journalInput.value.trim();
                    articleData.year = yearInput.value.trim();
                    articleData.impactFactor = impactFactorInput.value.trim();
                    articleData.citation = citationInput.value.trim();
                    articleData.description = ''; // 文献材料没有简介
                } else {
                    articleData.description = descInput.value.trim() || '无简介';
                }

                // Temporary flag to prevent immediate password prompt after saving an encrypted article
                justSavedEncryptedArticle = articleData.isEncrypted; // Set the flag if the article is encrypted

                const saveSuccess = saveArticleChanges(
                    articleData.id, { ...articleData,
                        encryptionPassword: encryptionPassword
                    }
                );

                if (saveSuccess) {
                    showNotification('文章已保存', 'success');
                    els.editActionsFixedSidebar.style.display = 'none'; // Hide fixed sidebar
                    viewArticle(articleData.id);
                } else {
                    justSavedEncryptedArticle = false;
                 }
            };

            const cancelButton = document.createElement('button');
            cancelButton.className = 'btn cancel-btn-bright';
            cancelButton.textContent = '取消';
            cancelButton.onclick = () => {
                els.editActionsFixedSidebar.style.display = 'none'; // Hide fixed sidebar
                article ? viewArticle(article.id) : loadArticles();
            };

            const backButton = document.createElement('button'); // This is the "返回" button
            backButton.className = 'btn btn-primary-blue'; // 修改：应用新的蓝色样式类
            backButton.textContent = '返回'; // Renamed from "返回文章" or "返回列表"
            backButton.onclick = () => {
                els.editActionsFixedSidebar.style.display = 'none'; // Hide fixed sidebar
                article ? viewArticle(article.id) : loadArticles(); // Logic remains the same
            };

            // 回到顶部按钮
            const scrollToTopButton = document.createElement('button');
            scrollToTopButton.className = 'btn btn-scroll-to-top';
            scrollToTopButton.textContent = '🔺';
            scrollToTopButton.title = '回到顶部';
            scrollToTopButton.onclick = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            // 回到底部按钮 (NEW)
            const scrollToBottomButton = document.createElement('button');
            scrollToBottomButton.className = 'btn btn-scroll-to-bottom'; // Use a new class
            scrollToBottomButton.textContent = '🔻';
            scrollToBottomButton.title = '跳到底部';
            scrollToBottomButton.onclick = () => {
                window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
            };

            els.editActionsFixedSidebar.append(scrollToBottomButton, saveButton, cancelButton, backButton, scrollToTopButton);


            // editForm.appendChild(buttonContainer); // Removed this line

            // Category select change event: toggle description/literature fields display
            categorySelect.onchange = () => {
                const isLiterature = categorySelect.value === '文献材料';
                descriptionGroup.style.display = isLiterature ? 'none' : 'block';
                literatureFieldsContainer.style.display = isLiterature ? 'flex' : 'none';
                if (isLiterature) {
                    descInput.value = ''; // Clear description when switching to literature
                } else {
                    journalInput.value = yearInput.value = impactFactorInput.value = citationInput.value = ''; // Clear literature fields when switching away
                }
            };

            // Initialize display of fields based on current category
            const currentCategory = article ? article.category : categorySelect.value;
            const isLiteratureInitial = currentCategory === '文献材料';
            descriptionGroup.style.display = isLiteratureInitial ? 'none' : 'block';
            literatureFieldsContainer.style.display = isLiteratureInitial ? 'flex' : 'none';

            els.articlesContainer.appendChild(editForm);
        };

        /**
         * Edit article (handles encrypted articles).
         * @param {number} id - Article ID.
         */
        const editArticle = id => {
            const articles = currentView === '回收站' ? Storage.getTrashedArticles() : Storage.getArticles(); // MODIFIED: 'trash' to '回收站'
            const article = articles.find(a => a.id === parseInt(id));
            if (!article) {
                showNotification('未找到该文章', 'error');
                return;
            }

            articleToProcess = article; // Set current article to process
            if (article.isEncrypted) {
                els.passwordPromptModal.dataset.actionType = 'edit_decrypt'; // Set action type to edit and decrypt
                showPasswordPrompt(); // Pop up password box
            } else {
                renderArticleForm(article); // Directly render edit form
            }
        };

        /**
         * Save article changes (including encryption/decryption logic).
         * @param {number} id - Article ID.
         * @param {Object} changes - Object containing new article data.
         * @returns {boolean} True if save was successful, false otherwise.
         */
        const saveArticleChanges = (id, changes) => {
            let articles = currentView === '回收站' ? Storage.getTrashedArticles() : Storage.getArticles(); // MODIFIED: 'trash' to '回收站'

            const dataToSave = { ...changes
            };
            delete dataToSave.encryptionPassword; // Do not save password directly

            if (changes.isEncrypted) { // If article is marked as encrypted
                if (!changes.encryptionPassword || !/^\d{6}$/.test(changes.encryptionPassword)) {
                    showNotification('保存加密文章需要提供6位数字密码', 'error');
                    return false;
                }
                // Encrypt all sensitive fields
                dataToSave.title = encryptData(changes.title, changes.encryptionPassword);
                dataToSave.content = encryptData(changes.content, changes.encryptionPassword);
                dataToSave.description = encryptData(changes.description, changes.encryptionPassword);
                if (changes.category === '文献材料') {
                    dataToSave.journal = encryptData(changes.journal, changes.encryptionPassword);
                    dataToSave.year = encryptData(changes.year, changes.encryptionPassword);
                    dataToSave.impactFactor = encryptData(changes.impactFactor, changes.encryptionPassword);
                    dataToSave.citation = encryptData(changes.citation, changes.encryptionPassword);
                }
            } else { // If article is not encrypted or decrypted
                if (dataToSave.category !== '文献材料') { // If not literature, clear literature-related fields
                    dataToSave.journal = dataToSave.year = dataToSave.impactFactor = dataToSave.citation = '';
                }
            }

            const articleIndex = articles.findIndex(a => a.id === parseInt(id));
            if (articleIndex === -1) { // If new article, add it
                articles.push({ ...dataToSave,
                    id: id
                });
            } else { // If existing article, update it
                Object.assign(articles[articleIndex], dataToSave);
            }

            if (currentView === '回收站') Storage.saveTrashedArticles(articles); // MODIFIED: 'trash' to '回收站'
            else Storage.saveArticles(articles);
            return true;
        };

        // --- Modals ---

        /**
         * Show generic modal.
         * @param {string} title - Modal title.
         * @param {string} message - Modal message.
         * @param {boolean} showInput - Whether to show input field.
         * @param {string} inputPlaceholder - Input field placeholder.
         * @param {Function} onConfirm - Confirm callback.
         * @param {Function} onCancel - Cancel callback.
         */
        const showGenericModal = (title, message, showInput, inputPlaceholder, onConfirm, onCancel) => {
            els.newCategoryModalTitle.textContent = title;
            els.newCategoryInput.style.display = showInput ? 'block' : 'none';
            els.newCategoryInput.placeholder = inputPlaceholder;
            els.newCategoryInput.value = '';

            els.modalMessageP.textContent = message || '';
            els.modalMessageP.style.display = message ? 'block' : 'none';

            els.confirmNewCategoryBtn.onclick = () => {
                if (onConfirm) onConfirm(els.newCategoryInput.value);
                hideNewCategoryModal();
            };
            els.cancelNewCategoryBtn.onclick = () => {
                if (onCancel) onCancel();
                hideNewCategoryModal();
            };

            els.newCategoryModal.classList.add('show'); // Show modal
            if (showInput) els.newCategoryInput.focus();
            else els.confirmNewCategoryBtn.focus();
        };

        /** Hide new category modal. */
        const hideNewCategoryModal = () => {
            els.newCategoryModal.classList.remove('show');
            // 将内容重置操作延迟执行，以确保模态框在视觉上完全消失后才重置内容。
            setTimeout(() => {
                els.newCategoryModalTitle.textContent = '创建新分类';
                els.newCategoryInput.style.display = 'block';
                els.newCategoryInput.placeholder = '请输入新分类名称';
                els.modalMessageP.style.display = 'none';
                // 在模态框完全隐藏后，清除按钮的事件监听器，以防止潜在的内存泄漏或意外行为。
                els.confirmNewCategoryBtn.onclick = null; 
                els.cancelNewCategoryBtn.onclick = null;
            }, 350); // 延迟 350 毫秒
        };

        /** Show password prompt modal. */
        const showPasswordPrompt = () => {
            els.passwordInputPrompt.value = '';
            const actionType = els.passwordPromptModal.dataset.actionType; // Get action type

            els.passwordModalTitle.textContent = actionType === 'encrypt' ? '设置加密密码' : '文章已加密';
            els.passwordModalMessage.textContent = actionType === 'encrypt' ? '请输入您想为此文章设置的6位数字密码。' : '输入6位数字密码（取消无反应则多点一次）。';

            els.passwordPromptModal.classList.add('show');
            els.passwordInputPrompt.focus();
            // 修正：为取消按钮绑定关闭模态框事件
            els.cancelPasswordPromptBtn.onclick = null; // 清除之前的事件处理器
            els.cancelPasswordPromptBtn.onclick = () => {
                hidePasswordPrompt(); // 隐藏密码输入模态框
                const actionType = els.passwordPromptModal.dataset.actionType; // 获取当前模态框的操作类型

                // 如果操作类型是 'view_decrypt' (点击加密文章查看详情) 或 'decrypt' (在加密文章详情页点击解锁)
                // 此时加密文章的占位符视图已经显示，所以只需隐藏模态框，无需跳转。
                if (actionType === 'view_decrypt' || actionType === 'decrypt') {
                    // 无需额外操作，加密文章的占位符视图已在背景中显示。
                    // `isViewingArticle` 和 `currentArticleId` 的状态应由 `viewArticle` 或 `displayEncryptedArticlePlaceholder` 维护。
                } else {
                    // 对于其他操作类型 (例如 'encrypt' 或 'edit_decrypt')，
                    // 如果用户取消密码输入，则返回文章列表。
                    isViewingArticle = false;
                    currentArticleId = null;
                    loadArticles();
                }
            };
        };

        /** Hide password prompt modal. */
        const hidePasswordPrompt = () => els.passwordPromptModal.classList.remove('show');

        // --- Category Sorting Functionality ---

        let draggedItem = null; // Currently dragged category item
        let dragOverItem = null; // Category item being dragged over

        /** Enable category sorting mode. */
        const enableCategorySorting = () => {
            isSortingCategories = true;
            els.categoriesList.classList.add('sorting-active'); // Add sorting active class
            els.createNewBtn.style.display = 'none';
            els.createCategoryBtn.style.display = 'none';
            els.exitSortingModeBtn.style.display = 'block'; // Show finish sorting button
            els.toggleBatchActionsBtn.style.display = 'none'; // Hide batch actions toggle button
            els.actualBatchActions.style.display = 'none'; // Hide actual batch actions area
            showNotification('已进入分类排序模式，拖动分类进行排序', 'info');
            loadCategories(); // Reload categories to make them draggable
        };

        /** Disable category sorting mode. */
        const disableCategorySorting = () => {
            isSortingCategories = false;
            els.categoriesList.classList.remove('sorting-active');
            els.createNewBtn.style.display = 'block';
            els.createCategoryBtn.style.display = 'block';
            els.exitSortingModeBtn.style.display = 'none'; // Hide finish sorting button
            // 批量操作按钮现在始终可见，此处不再根据视图隐藏
            // if (currentView !== 'trash') els.toggleBatchActionsBtn.style.display = 'block';
            els.toggleBatchActionsBtn.style.display = 'block'; // 确保退出排序模式后批量操作按钮可见
            showNotification('分类排序已完成', 'success');

            const newOrder = [];
            // Get new category order
            els.categoriesList.querySelectorAll('li.draggable a').forEach(link => newOrder.push(link.dataset.category));
            // Ensure "全部作品" and "回收站" 是始终在列表的开头和结尾的特殊分类，不应被拖拽排序影响其位置。
            // 它们在 loadCategories 中被特殊处理，不添加 draggable 类，所以这里不需要特别过滤它们，
            // 但为了逻辑严谨性，可以确保它们不会出现在 newOrder 中。
            allCategories = newOrder.filter(cat => cat !== '全部作品' && cat !== '回收站');
            saveCategories(); // Save new order
            loadCategories(); // Reload category list
            hideAllDeleteButtons(); // Hide all delete buttons
        };

        let categoryHeadingLongPressTimer = null; // Timer for long press on category heading
        let categoryHeadingLongPressStartX = 0; // Starting X coordinate for long press
        let categoryHeadingLongPressStartY = 0; // Starting Y coordinate for long press

        /**
         * Handle mouse down/touch start event on category heading (for long press detection).
         * @param {MouseEvent|TouchEvent} e - Event object.
         */
        const handleCategoryHeadingMouseDown = e => {
            if (e.button === 2 || isSortingCategories) return; // Ignore right click and if already in sorting mode
            if (e.type === 'touchstart') e.preventDefault(); // Prevent default touch behavior to avoid scrolling

            categoryHeadingLongPressStartX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
            categoryHeadingLongPressStartY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);

            // Set a timer, if not released or moved within 500ms, enter sorting mode
            categoryHeadingLongPressTimer = setTimeout(() => {
                enableCategorySorting();
                categoryHeadingLongPressTimer = null;
            }, 500);
        };

        /** Handle mouse up/touch end event on category heading. */
        const handleCategoryHeadingMouseUp = () => {
            if (categoryHeadingLongPressTimer) {
                clearTimeout(categoryHeadingLongPressTimer); // Clear timer
                categoryHeadingLongPressTimer = null;
            }
        };

        /**
         * Handle mouse move/touch move event on category heading.
         * @param {MouseEvent|TouchEvent} e - Event object.
         */
        const handleCategoryHeadingMouseMove = e => {
            if (categoryHeadingLongPressTimer) {
                const currentX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : categoryHeadingLongPressStartX);
                const currentY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : categoryHeadingLongPressStartY);
                // If moved beyond threshold, cancel long press
                if (Math.abs(currentX - categoryHeadingLongPressStartX) > 10 || Math.abs(currentY - categoryHeadingLongPressStartY) > 10) {
                    clearTimeout(categoryHeadingLongPressTimer);
                    categoryHeadingLongPressTimer = null;
                }
            }
        };

        /**
         * Handle drag start event.
         * @param {DragEvent} e - Event object.
         */
        const handleDragStart = e => {
            if (!isSortingCategories) return;
            draggedItem = e.currentTarget; // Set the dragged element
            e.dataTransfer.effectAllowed = 'move'; // Allow move operation
            e.dataTransfer.setData('text/html', draggedItem.innerHTML); // Pass data (though not strictly needed here)
            draggedItem.classList.add('dragging'); // Add dragging style
        };

        /**
         * Handle drag over event.
         * @param {DragEvent} e - Event object.
         */
        const handleDragOver = e => {
            if (!isSortingCategories) return;
            e.preventDefault(); // Prevent default behavior, allow drop
            e.dataTransfer.dropEffect = 'move';

            const targetLi = e.currentTarget; // Target element being dragged over
            // Ensure not dragging self, and not a special category
            if (targetLi && draggedItem && targetLi !== draggedItem && !['全部作品', '回收站'].includes(targetLi.querySelector('a').dataset.category)) {
                const rect = targetLi.getBoundingClientRect();
                const offsetY = e.clientY - rect.top; // Vertical position of mouse within target element

                // Remove all drag indicator styles
                QA('.categories li').forEach(li => li.classList.remove('drag-over', 'drag-over-bottom'));
                // Add drag indicator style based on mouse position (above or below)
                targetLi.classList.add(offsetY < rect.height / 2 ? 'drag-over' : 'drag-over-bottom');
                dragOverItem = targetLi; // Set the element being dragged over
            } else {
                e.dataTransfer.dropEffect = 'none'; // Do not allow drop
            }
        };

        /**
         * Handle drag leave event.
         * @param {DragEvent} e - Event object.
         */
        const handleDragLeave = e => {
            if (!isSortingCategories) return;
            e.currentTarget.classList.remove('drag-over', 'drag-over-bottom'); // Remove drag indicator style
            dragOverItem = null;
        };

        /**
         * Handle drop event.
         * @param {DragEvent} e - Event object.
         */
        const handleDrop = e => {
            if (!isSortingCategories) return;
            e.preventDefault();
            if (draggedItem && dragOverItem && draggedItem !== dragOverItem) {
                const referenceNode = dragOverItem;
                const rect = referenceNode.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                // Insert before or after target element based on mouse position
                els.categoriesList.insertBefore(draggedItem, offsetY < rect.height / 2 ? referenceNode : referenceNode.nextSibling);
            }
        };

        /** Handle drag end event. */
        const handleDragEnd = () => {
            if (!isSortingCategories) return;
            draggedItem.classList.remove('dragging'); // Remove dragging style
            QA('.categories li').forEach(li => li.classList.remove('drag-over', 'drag-over-bottom')); // Remove all drag indicator styles
            draggedItem = null;
            dragOverItem = null;
        };

        // --- Initialization ---

        /** Initialize demo data (if not present in localStorage). */
        const initializeDemoData = () => {
            if (!localStorage.getItem('articles')) Storage.saveArticles([]);
            if (!localStorage.getItem('trashedArticles')) Storage.saveTrashedArticles([]);

            // 新增: 确保所有文章都有 'isPinned' 属性
            let articles = Storage.getArticles();
            let updatedArticles = false;
            articles = articles.map(article => {
                if (typeof article.isPinned === 'undefined') {
                    article.isPinned = false;
                    updatedArticles = true;
                }
                return article;
            });
            if (updatedArticles) {
                Storage.saveArticles(articles);
            }

            // 新增: 同样处理回收站中的文章
            let trashedArticles = Storage.getTrashedArticles();
            let updatedTrashedArticles = false;
            trashedArticles = trashedArticles.map(article => {
                if (typeof article.isPinned === 'undefined') {
                    article.isPinned = false;
                    updatedTrashedArticles = true;
                }
                return article;
            });
            if (updatedTrashedArticles) {
                Storage.saveTrashedArticles(trashedArticles);
            }

            allCategories = Storage.getCategories();
            const categoriesSet = new Set(allCategories);
            DEFAULT_CATEGORIES.forEach(cat => categoriesSet.add(cat));
            allCategories = Array.from(categoriesSet);
            Storage.saveCategories(allCategories);
        };

        // 定义处理点击文档以隐藏设置菜单的函数
        const handleDocumentClickToHideSettings = e => {
            // 如果点击目标不在设置下拉菜单内，也不在设置切换按钮内
            if (!els.settingsDropdownMenu.contains(e.target) && !els.settingsMenuToggle.contains(e.target)) {
                els.settingsDropdownMenu.classList.remove('show');
                // 菜单隐藏后，移除此监听器，避免不必要的检查
                document.removeEventListener('click', handleDocumentClickToHideSettings);
            }

            // Hide color palette if click outside
            const colorPickerWrapper = Q('.color-picker-wrapper');
            if (colorPickerWrapper && !colorPickerWrapper.contains(e.target)) {
                const bgColorPalette = colorPickerWrapper.querySelector('.color-palette');
                if (bgColorPalette) bgColorPalette.style.display = 'none';
            }

            // Hide font palette if click outside
            const fontPickerWrapper = Q('.font-picker-wrapper');
            if (fontPickerWrapper && !fontPickerWrapper.contains(e.target)) {
                const fontPalette = fontPickerWrapper.querySelector('.font-palette');
                if (fontPalette) fontPalette.style.display = 'none';
            }

            // NEW: Hide alignment palette if click outside
            const alignmentPickerWrapper = Q('.alignment-picker-wrapper');
            if (alignmentPickerWrapper && !alignmentPickerWrapper.contains(e.target)) {
                const alignmentPalette = alignmentPickerWrapper.querySelector('.alignment-palette');
                if (alignmentPalette) alignmentPalette.style.display = 'none';
            }
        };

        /** Initialize all event listeners. */
        const initializeEventListeners = () => {
            // Settings menu toggle
            els.settingsMenuToggle.onclick = e => {
                e.stopPropagation(); // 阻止事件冒泡到 document，防止立即关闭菜单
                els.settingsDropdownMenu.classList.toggle('show');

                // 根据菜单的显示状态，动态添加或移除 document 上的点击监听器
                if (els.settingsDropdownMenu.classList.contains('show')) {
                    // 使用 setTimeout 延迟添加监听器，确保当前点击事件完全处理完毕
                    // 这样可以避免在菜单刚打开时，document 上的监听器立即捕获到这个点击并关闭菜单
                    setTimeout(() => {
                        document.addEventListener('click', handleDocumentClickToHideSettings);
                    }, 0);
                } else {
                    // 如果菜单被关闭（通过再次点击切换按钮），则移除监听器
                    document.removeEventListener('click', handleDocumentClickToHideSettings);
                }
            };

            // Search functionality
            els.searchBtn.onclick = searchArticles;
            els.searchInput.onkeypress = e => {
                if (e.key === 'Enter') searchArticles();
            };
            // Create new article
            els.createNewBtn.onclick = e => {
                e.preventDefault();
                createNewArticle();
            };

            // Create new category modal
            els.createCategoryBtn.onclick = () => showGenericModal('创建新分类', '', true, '请输入新分类名称', addNewCategory, () => showNotification('已取消创建新分类', 'info'));
            els.newCategoryInput.onkeypress = e => {
                if (e.key === 'Enter' && els.confirmNewCategoryBtn.onclick) els.confirmNewCategoryBtn.onclick();
            };

            // Password prompt modal confirm button
            els.confirmPasswordPromptBtn.onclick = () => {
                const password = els.passwordInputPrompt.value;
                if (!/^\d{6}$/.test(password)) {
                    showNotification('密码必须是6位数字', 'error');
                    return;
                }

                const actionType = els.passwordPromptModal.dataset.actionType;
                if (!articleToProcess) {
                    showNotification('没有文章需要处理', 'error');
                    hidePasswordPrompt();
                    return;
                }

                if (actionType === 'encrypt') { // Encrypt operation
                    const saveSuccess = saveArticleChanges(articleToProcess.id, { ...articleToProcess,
                        isEncrypted: true,
                        encryptionPassword: password
                    });
                    if (saveSuccess) {
                        hidePasswordPrompt();
                        showNotification('文章已成功加密', 'success');
                        // Reload and display the encrypted article placeholder
                        const newlyEncryptedArticle = (Storage.getArticles()).find(a => a.id === articleToProcess.id);
                        if (newlyEncryptedArticle) {
                            // When encrypting from detail view, we should just show the placeholder, not prompt again.
                            // The `viewArticle` function would normally prompt, but we are already in the modal.
                            // So, just call displayEncryptedArticlePlaceholder directly.
                            displayEncryptedArticlePlaceholder(newlyEncryptedArticle);
                        } else {
                            loadArticles();
                        }
                        articleToProcess = null;
                    }
                } else if (['decrypt', 'view_decrypt', 'edit_decrypt'].includes(actionType)) { // Decrypt operation
                    // Attempt to decrypt all potentially encrypted fields
                    const decrypted = {
                        title: decryptData(articleToProcess.title, password),
                        content: decryptData(articleToProcess.content, password),
                        description: decryptData(articleToProcess.description, password),
                        journal: articleToProcess.category === '文献材料' ? decryptData(articleToProcess.journal, password) : '',
                        year: articleToProcess.category === '文献材料' ? decryptData(articleToProcess.year, password) : '',
                        impactFactor: articleToProcess.category === '文献材料' ? decryptData(articleToProcess.impactFactor, password) : '',
                        citation: articleToProcess.category === '文献材料' ? decryptData(articleToProcess.citation, password) : ''
                    };

                    // Check if all fields are successfully decrypted
                    // Note: If a field was empty and encrypted, decryptData might return null.
                    // We need to ensure that the original encrypted field was not empty if we expect a non-null result.
                    // For simplicity, we assume successful decryption means all relevant fields are not null.
                    // If any decrypted value is null and the original encrypted value was not empty, then it's a failure.
                    const decryptionSuccessful = Object.keys(decrypted).every(key => {
                        const originalValue = articleToProcess[key];
                        const decryptedValue = decrypted[key];
                        // If original value was encrypted and not empty, and decryption resulted in null, then it's a failure.
                        if (articleToProcess.isEncrypted && originalValue && decryptedValue === null) {
                            return false;
                        }
                        return true;
                    });


                    if (decryptionSuccessful) {
                        const fullDecryptedArticle = { ...articleToProcess, ...decrypted, isEncrypted: false }; // 强制解密状态
                        hidePasswordPrompt();
                        showNotification('文章已成功解密', 'success');

                        if (actionType === 'view_decrypt' || actionType === 'decrypt') {
                            // 保存解密状态到本地
                            saveArticleChanges(fullDecryptedArticle.id, fullDecryptedArticle);
                            // 立即显示解密后的内容
                            displayArticleDetails(fullDecryptedArticle);
                        } else if (actionType === 'edit_decrypt') {
                            renderArticleForm(fullDecryptedArticle);
                        }
                        articleToProcess = null;
                    } else {
                        showNotification('密码错误，请重试', 'error');
                        els.passwordInputPrompt.value = ''; // Clear password input
                    }
                }
            };
            // Password input field enter key triggers confirm
            els.passwordInputPrompt.onkeypress = e => {
                if (e.key === 'Enter') els.confirmPasswordPromptBtn.click();
            };

            // Trash empty button
            els.emptyTrashBtn.onclick = emptyTrash;
            // 为“全部恢复”按钮绑定事件监听器
            if (els.batchRestoreAllBtn) els.batchRestoreAllBtn.onclick = batchRestoreFromTrash;
            // Select all checkbox
            if (els.selectAllCheckbox) els.selectAllCheckbox.onchange = toggleSelectAll;
            // Batch delete (now handles both move to trash and permanent delete)
            els.batchDeleteBtn.onclick = handleBatchDelete;
            // Recategorize select change (also triggers batch recategorize/restore)
            els.recategorizeSelect.onchange = handleBatchRecategorizeOrRestore;
            // Batch restore (the "restore all" button, kept for backward compatibility if needed, but hidden in trash view now)
            els.batchRestoreBtn.onclick = batchRestoreFromTrash;

            // Batch actions toggle button
            els.toggleBatchActionsBtn.onclick = () => {
                isBatchActionsVisible = !isBatchActionsVisible; // 切换状态
                els.actualBatchActions.style.display = isBatchActionsVisible ? 'flex' : 'none'; // 根据状态显示或隐藏
                if (!isBatchActionsVisible) { // 如果隐藏批量操作，则取消全选
                    els.selectAllCheckbox.checked = false;
                    selectedArticleIds = [];
                    QA('.article-checkbox').forEach(cb => cb.checked = false);
                }
            };

            // Click outside to hide category delete buttons (original global listener)
            // This listener is not affected by the settings menu fix, and still handles category delete buttons.
            document.onclick = e => {
                // Hide settings dropdown if click outside
                // This part is now handled by handleDocumentClickToHideSettings, which is added/removed dynamically.
                // Keeping this for other general clicks not covered by the settings menu logic

                // Hide category delete buttons if click outside
                if (Q('.category-delete-btn[style*="display: flex"]') && !e.target.closest('.categories li a') && !e.target.closest('.category-delete-btn')) {
                    hideAllDeleteButtons();
                }

                // The palette hiding logic is now within handleDocumentClickToHideSettings,
                // which is attached to document.addEventListener('click')
            };

            // Theme toggle
            els.themeToggleBtn.onclick = toggleTheme;
            // Set background image
            els.backgroundImageInput.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = ev => {
                        document.body.style.backgroundImage = `url(${ev.target.result})`;
                        localStorage.setItem('backgroundImage', ev.target.result);
                        showNotification('背景图片已设置', 'success');
                    };
                    reader.readAsDataURL(file);
                }
            };
            els.setBgButton.onclick = () => els.backgroundImageInput.click();
            els.clearBackgroundBtn.onclick = clearBackgroundImage;

            // Category heading long press/drag events
            els.categoryHeading.addEventListener('mousedown', handleCategoryHeadingMouseDown);
            els.categoryHeading.addEventListener('mouseup', handleCategoryHeadingMouseUp);
            els.categoryHeading.addEventListener('mousemove', handleCategoryHeadingMouseMove);
            els.categoryHeading.addEventListener('mouseleave', handleCategoryHeadingMouseUp); // Mouse leave also counts as release
            els.categoryHeading.addEventListener('touchstart', handleCategoryHeadingMouseDown);
            els.categoryHeading.addEventListener('touchend', handleCategoryHeadingMouseUp);
            els.categoryHeading.addEventListener('touchmove', handleCategoryHeadingMouseMove);
            els.categoryHeading.addEventListener('contextmenu', e => e.preventDefault()); // Prevent default context menu

            // Category list drag events
            els.categoriesList.addEventListener('dragstart', handleDragStart);
            els.categoriesList.addEventListener('dragover', handleDragOver);
            els.categoriesList.addEventListener('dragleave', handleDragLeave);
            els.categoriesList.addEventListener('drop', handleDrop);
            els.categoriesList.addEventListener('dragend', handleDragEnd);

            // Exit sorting mode
            els.exitSortingModeBtn.onclick = disableCategorySorting;
            // Tip button
            els.tipBtn.onclick = () => showGenericModal('提示', '1.长按“作品分类”，可调整文章分类的顺序。\n2.推荐保持透明化模式，非透明化模式多用于测试bug。\n3.评论区附录部分由于无法塞表情包进去，会采用（等简单符号替代。\n4.简介以？或（结尾的为自评简介；否则为原文简介（该类型可能存在微量排版变化）',  false, '', () => {}, () => {});
// 隐藏取消按钮
els.cancelNewCategoryBtn.style.display = 'none';
            // 隐藏取消按钮
            els.cancelNewCategoryBtn.style.display = 'none';
            // Transparency toggle
            els.toggleTransparencyBtn.onclick = () => isTransparentMode ? removeTransparency() : applyTransparency();
            // View mode toggle
            if (els.toggleViewModeBtn) els.toggleViewModeBtn.onclick = toggleViewMode;
        };

        // Initialize when DOM content is loaded
        document.addEventListener('DOMContentLoaded', () => {
            initializeDemoData(); // Initialize data
            applyThemePreference(); // Apply theme
            applySavedBackground(); // Apply background
            applyTransparencyPreference(); // Apply transparency mode
            applyViewModePreference(); // Apply view mode
            loadCategories(); // Load categories
            initializeEventListeners(); // Initialize event listeners
            loadArticles(); // Load articles

            // Fix: Ensure execCommand applies styles via CSS for better font control
            // This makes execCommand('fontName') apply font-family via CSS <span> tags, which is more reliable.
            document.execCommand('styleWithCSS', false, true);
        });
    </script>
</body>
</html>